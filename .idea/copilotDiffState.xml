<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/Inc/i2c.h">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Inc/i2c.h" />
              <option name="updatedContent" value="// filepath: /Users/haoyi/Documents/Code/Electronics_for_embedded_systems/Motor_monitor/Software/Inc/i2c.h&#10;/**&#10; * @file i2c.h&#10; * @author Haoyi Chen&#10; * @date 2025-08-08&#10; * @brief STM32F4 I2C register-level driver header&#10; *&#10; * @details This file contains I2C function declarations, structures, and macro definitions&#10; * for STM32F407 series microcontrollers.&#10; */&#10;&#10;#ifndef I2C_H&#10;#define I2C_H&#10;&#10;#include &quot;stm32f407xx.h&quot;&#10;&#10;/**&#10; * @brief I2C initialization configuration structure&#10; */&#10;typedef struct {&#10;    uint32_t ClockSpeed;       /**&lt; I2C clock frequency in Hz */&#10;    uint8_t OwnAddress1;       /**&lt; First device own address */&#10;    uint8_t AddressingMode;    /**&lt; I2C addressing mode (7 or 10 bit) */&#10;    uint8_t DualAddressMode;   /**&lt; Dual addressing mode enable/disable */&#10;    uint8_t OwnAddress2;       /**&lt; Second device own address (if dual mode enabled) */&#10;    uint8_t GeneralCallMode;   /**&lt; General call mode enable/disable */&#10;    uint8_t NoStretchMode;     /**&lt; Clock stretching disable/enable */&#10;    uint8_t DutyCycle;         /**&lt; Fast mode duty cycle */&#10;} I2C_InitTypeDef;&#10;&#10;/**&#10; * @name I2C Addressing Mode&#10; * @{&#10; */&#10;#define I2C_ADDRESSINGMODE_7BIT    0x00000000U  /**&lt; 7-bit addressing mode */&#10;#define I2C_ADDRESSINGMODE_10BIT   0x00000080U  /**&lt; 10-bit addressing mode */&#10;/** @} */&#10;&#10;/**&#10; * @name I2C Dual Addressing Mode&#10; * @{&#10; */&#10;#define I2C_DUALADDRESS_DISABLE    0x00000000U  /**&lt; Dual addressing mode disabled */&#10;#define I2C_DUALADDRESS_ENABLE     0x00000001U  /**&lt; Dual addressing mode enabled */&#10;/** @} */&#10;&#10;/**&#10; * @name I2C General Call Mode&#10; * @{&#10; */&#10;#define I2C_GENERALCALL_DISABLE    0x00000000U  /**&lt; General call mode disabled */&#10;#define I2C_GENERALCALL_ENABLE     0x00000040U  /**&lt; General call mode enabled */&#10;/** @} */&#10;&#10;/**&#10; * @name I2C No Stretch Mode&#10; * @{&#10; */&#10;#define I2C_NOSTRETCH_DISABLE      0x00000000U  /**&lt; Clock stretching enabled */&#10;#define I2C_NOSTRETCH_ENABLE       0x00000080U  /**&lt; Clock stretching disabled */&#10;/** @} */&#10;&#10;/**&#10; * @name I2C Fast Mode Duty Cycle&#10; * @{&#10; */&#10;#define I2C_DUTYCYCLE_2            0x00000000U  /**&lt; Fast mode duty cycle tlow/thigh = 2 */&#10;#define I2C_DUTYCYCLE_16_9         0x00004000U  /**&lt; Fast mode duty cycle tlow/thigh = 16/9 */&#10;/** @} */&#10;&#10;/**&#10; * @name I2C Direction (for transfer functions)&#10; * @{&#10; */&#10;#define I2C_DIRECTION_TRANSMIT     0x00        /**&lt; I2C master transmitter direction */&#10;#define I2C_DIRECTION_RECEIVE      0x01        /**&lt; I2C master receiver direction */&#10;/** @} */&#10;&#10;/**&#10; * @name I2C Memory Address Size&#10; * @{&#10; */&#10;#define I2C_MEMADD_SIZE_8BIT       0x01        /**&lt; 8-bit memory address size */&#10;#define I2C_MEMADD_SIZE_16BIT      0x02        /**&lt; 16-bit memory address size */&#10;/** @} */&#10;&#10;/**&#10; * @name I2C Timeout values&#10; * @{&#10; */&#10;#define I2C_TIMEOUT_FLAG           10000       /**&lt; Timeout value for flag waiting */&#10;#define I2C_TIMEOUT_BUSY_FLAG      25000       /**&lt; Timeout value for busy flag waiting */&#10;/** @} */&#10;&#10;/**&#10; * @name I2C Status flags&#10; * @{&#10; */&#10;#define I2C_FLAG_BUSY              0x00020000U   /**&lt; Bus busy flag */&#10;#define I2C_FLAG_MSL               0x00010000U   /**&lt; Master/Slave flag */&#10;#define I2C_FLAG_TXE               0x00000080U   /**&lt; Data register empty flag (transmitter) */&#10;#define I2C_FLAG_RXNE              0x00000040U   /**&lt; Data register not empty flag (receiver) */&#10;#define I2C_FLAG_STOPF             0x00000010U   /**&lt; Stop detection flag */&#10;#define I2C_FLAG_ADD10             0x00000008U   /**&lt; 10-bit header sent flag */&#10;#define I2C_FLAG_BTF               0x00000004U   /**&lt; Byte transfer finished flag */&#10;#define I2C_FLAG_ADDR              0x00000002U   /**&lt; Address sent flag */&#10;#define I2C_FLAG_SB                0x00000001U   /**&lt; Start bit flag */&#10;/** @} */&#10;&#10;/**&#10; * @brief Initialize I2C with the specified parameters&#10; * &#10; * @param I2Cx I2C instance (I2C1, I2C2, or I2C3)&#10; * @param init Pointer to I2C initialization structure&#10; * &#10; * @note I2C clock must be enabled separately via RCC registers before calling this function&#10; */&#10;void i2c_init(I2C_TypeDef *I2Cx, I2C_InitTypeDef *init);&#10;&#10;/**&#10; * @brief Initialize GPIO pins for I2C&#10; * &#10; * @param I2Cx I2C instance (I2C1, I2C2, or I2C3)&#10; * @param GPIOx GPIO port for SCL pin (GPIOA, GPIOB, etc.)&#10; * @param SCL_Pin SCL pin number (0-15)&#10; * @param SDA_Pin SDA pin number (0-15)&#10; * &#10; * @note GPIO clock must be enabled separately via RCC registers&#10; */&#10;void i2c_gpio_init(I2C_TypeDef *I2Cx, GPIO_TypeDef *GPIOx, uint8_t SCL_Pin, uint8_t SDA_Pin);&#10;&#10;/**&#10; * @brief Check if the I2C bus is free&#10; * &#10; * @param I2Cx I2C instance (I2C1, I2C2, or I2C3)&#10; * @return uint8_t 1 if bus is free, 0 if busy&#10; */&#10;uint8_t i2c_is_bus_free(I2C_TypeDef *I2Cx);&#10;&#10;/**&#10; * @brief Wait for a specific I2C flag to be set or reset&#10; * &#10; * @param I2Cx I2C instance (I2C1, I2C2, or I2C3)&#10; * @param flag Flag to check&#10; * @param status Expected status (1 for set, 0 for reset)&#10; * @param timeout Timeout value&#10; * @return uint8_t 0 if successful (flag matched expected state), 1 if timeout&#10; */&#10;uint8_t i2c_wait_flag(I2C_TypeDef *I2Cx, uint32_t flag, uint8_t status, uint32_t timeout);&#10;&#10;/**&#10; * @brief Generate start condition on I2C bus&#10; * &#10; * @param I2Cx I2C instance (I2C1, I2C2, or I2C3)&#10; * @return uint8_t 0 if successful, 1 if error&#10; */&#10;uint8_t i2c_generate_start(I2C_TypeDef *I2Cx);&#10;&#10;/**&#10; * @brief Generate stop condition on I2C bus&#10; * &#10; * @param I2Cx I2C instance (I2C1, I2C2, or I2C3)&#10; * @return uint8_t 0 if successful, 1 if error&#10; */&#10;uint8_t i2c_generate_stop(I2C_TypeDef *I2Cx);&#10;&#10;/**&#10; * @brief Send 7-bit or 10-bit device address&#10; * &#10; * @param I2Cx I2C instance (I2C1, I2C2, or I2C3)&#10; * @param DevAddress Target device address&#10; * @param Direction Direction (I2C_DIRECTION_TRANSMIT or I2C_DIRECTION_RECEIVE)&#10; * @return uint8_t 0 if successful, 1 if error&#10; */&#10;uint8_t i2c_send_address(I2C_TypeDef *I2Cx, uint16_t DevAddress, uint8_t Direction);&#10;&#10;/**&#10; * @brief Master transmit data to a slave device&#10; * &#10; * @param I2Cx I2C instance (I2C1, I2C2, or I2C3)&#10; * @param DevAddress Target device address&#10; * @param pData Pointer to data buffer&#10; * @param Size Amount of data to be sent&#10; * @param Timeout Timeout value&#10; * @return uint8_t 0 if successful, 1 if error&#10; */&#10;uint8_t i2c_master_transmit(I2C_TypeDef *I2Cx, uint16_t DevAddress, uint8_t *pData, uint16_t Size, uint32_t Timeout);&#10;&#10;/**&#10; * @brief Master receive data from a slave device&#10; * &#10; * @param I2Cx I2C instance (I2C1, I2C2, or I2C3)&#10; * @param DevAddress Target device address&#10; * @param pData Pointer to data buffer&#10; * @param Size Amount of data to be received&#10; * @param Timeout Timeout value&#10; * @return uint8_t 0 if successful, 1 if error&#10; */&#10;uint8_t i2c_master_receive(I2C_TypeDef *I2Cx, uint16_t DevAddress, uint8_t *pData, uint16_t Size, uint32_t Timeout);&#10;&#10;/**&#10; * @brief Write to a memory address of an I2C slave device&#10; * &#10; * @param I2Cx I2C instance (I2C1, I2C2, or I2C3)&#10; * @param DevAddress Target device address&#10; * @param MemAddress Internal memory address&#10; * @param MemAddSize Size of memory address (I2C_MEMADD_SIZE_8BIT or I2C_MEMADD_SIZE_16BIT)&#10; * @param pData Pointer to data buffer&#10; * @param Size Amount of data to be sent&#10; * @param Timeout Timeout value&#10; * @return uint8_t 0 if successful, 1 if error&#10; */&#10;uint8_t i2c_mem_write(I2C_TypeDef *I2Cx, uint16_t DevAddress, uint16_t MemAddress, &#10;                      uint8_t MemAddSize, uint8_t *pData, uint16_t Size, uint32_t Timeout);&#10;&#10;/**&#10; * @brief Read from a memory address of an I2C slave device&#10; * &#10; * @param I2Cx I2C instance (I2C1, I2C2, or I2C3)&#10; * @param DevAddress Target device address&#10; * @param MemAddress Internal memory address&#10; * @param MemAddSize Size of memory address (I2C_MEMADD_SIZE_8BIT or I2C_MEMADD_SIZE_16BIT)&#10; * @param pData Pointer to data buffer&#10; * @param Size Amount of data to be read&#10; * @param Timeout Timeout value&#10; * @return uint8_t 0 if successful, 1 if error&#10; */&#10;uint8_t i2c_mem_read(I2C_TypeDef *I2Cx, uint16_t DevAddress, uint16_t MemAddress, &#10;                     uint8_t MemAddSize, uint8_t *pData, uint16_t Size, uint32_t Timeout);&#10;&#10;/**&#10; * @brief Check if a device is ready to communicate&#10; * &#10; * @param I2Cx I2C instance (I2C1, I2C2, or I2C3)&#10; * @param DevAddress Target device address&#10; * @param Trials Number of trials&#10; * @param Timeout Timeout value&#10; * @return uint8_t 0 if device is ready, 1 if not ready&#10; */&#10;uint8_t i2c_is_device_ready(I2C_TypeDef *I2Cx, uint16_t DevAddress, uint8_t Trials, uint32_t Timeout);&#10;&#10;#endif /* I2C_H */" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Inc/system_init.h">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Inc/system_init.h" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Inc/systick.h">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Inc/systick.h" />
              <option name="originalContent" value="/**&#10; * @file systick_functions.h&#10; * @author Haoyi Chen&#10; * @date 2025-08-10&#10; * @brief SysTick timer common functions and utilities&#10; *&#10; * @details This file contains commonly used SysTick timer functions for&#10; * time keeping, delays, and timing applications in bare-metal STM32 projects.&#10; */&#10;&#10;#ifndef SYSTICK_FUNCTIONS_H&#10;#define SYSTICK_FUNCTIONS_H&#10;&#10;#include &quot;stm32f407xx.h&quot;&#10;#include &lt;stdint.h&gt;&#10;&#10;/* Global system tick counter (volatile for interrupt access) */&#10;extern volatile uint32_t system_tick_ms;&#10;extern volatile uint32_t system_tick_us;&#10;&#10;/**&#10; * @name SysTick Configuration Constants&#10; * @{&#10; */&#10;#define SYSTICK_FREQUENCY_HZ    1000    /**&lt; SysTick frequency in Hz (1kHz = 1ms) */&#10;#define SYSTICK_FREQUENCY_US    1000000 /**&lt; SysTick frequency for microsecond timing */&#10;/** @} */&#10;&#10;/**&#10; * @name Core SysTick Functions&#10; * @{&#10; */&#10;&#10;/**&#10; * @brief Initialize SysTick timer for 1ms interrupts&#10; * &#10; * @details Configures SysTick to generate interrupts every 1ms&#10; *          using the system clock frequency&#10; * &#10; * @param system_clock_hz System clock frequency in Hz (typically 168MHz for STM32F407)&#10; * @return uint8_t 0 if successful, 1 if error&#10; */&#10;uint8_t systick_init_ms(uint32_t system_clock_hz);&#10;&#10;/**&#10; * @brief Initialize SysTick timer for microsecond precision&#10; * &#10; * @details Configures SysTick for higher precision timing (typically 100µs interrupts)&#10; * &#10; * @param system_clock_hz System clock frequency in Hz&#10; * @param interval_us Interrupt interval in microseconds&#10; * @return uint8_t 0 if successful, 1 if error&#10; */&#10;uint8_t systick_init_us(uint32_t system_clock_hz, uint32_t interval_us);&#10;&#10;/**&#10; * @brief Enable SysTick timer&#10; */&#10;void systick_enable(void);&#10;&#10;/**&#10; * @brief Disable SysTick timer&#10; */&#10;void systick_disable(void);&#10;&#10;/**&#10; * @brief SysTick interrupt handler (to be called in SysTick_Handler)&#10; */&#10;void systick_irq_handler(void);&#10;&#10;/** @} */&#10;&#10;/**&#10; * @name Time Keeping Functions&#10; * @{&#10; */&#10;&#10;/**&#10; * @brief Get current system time in milliseconds&#10; * &#10; * @return uint32_t Current time in milliseconds since system start&#10; */&#10;uint32_t systick_get_ms(void);&#10;&#10;/**&#10; * @brief Get current system time in microseconds&#10; * &#10; * @return uint32_t Current time in microseconds since system start&#10; */&#10;uint32_t systick_get_us(void);&#10;&#10;/**&#10; * @brief Get elapsed time since a reference point in milliseconds&#10; * &#10; * @param start_time_ms Reference time in milliseconds&#10; * @return uint32_t Elapsed time in milliseconds&#10; */&#10;uint32_t systick_elapsed_ms(uint32_t start_time_ms);&#10;&#10;/**&#10; * @brief Get elapsed time since a reference point in microseconds&#10; * &#10; * @param start_time_us Reference time in microseconds&#10; * @return uint32_t Elapsed time in microseconds&#10; */&#10;uint32_t systick_elapsed_us(uint32_t start_time_us);&#10;&#10;/** @} */&#10;&#10;/**&#10; * @name Delay Functions&#10; * @{&#10; */&#10;&#10;/**&#10; * @brief Blocking delay in milliseconds&#10; * &#10; * @param delay_ms Delay time in milliseconds&#10; */&#10;void systick_delay_ms(uint32_t delay_ms);&#10;&#10;/**&#10; * @brief Blocking delay in microseconds&#10; * &#10; * @param delay_us Delay time in microseconds&#10; */&#10;void systick_delay_us(uint32_t delay_us);&#10;&#10;/**&#10; * @brief Non-blocking delay check&#10; * &#10; * @param start_time_ms Start time reference&#10; * @param delay_ms Desired delay in milliseconds&#10; * @return uint8_t 1 if delay period has elapsed, 0 otherwise&#10; */&#10;uint8_t systick_delay_elapsed(uint32_t start_time_ms, uint32_t delay_ms);&#10;&#10;/** @} */&#10;&#10;/**&#10; * @name Timer Utilities&#10; * @{&#10; */&#10;&#10;/**&#10; * @brief Simple timer structure for non-blocking operations&#10; */&#10;typedef struct {&#10;    uint32_t start_time;    /**&lt; Timer start time in ms */&#10;    uint32_t interval;      /**&lt; Timer interval in ms */&#10;    uint8_t enabled;        /**&lt; Timer enabled flag */&#10;    uint8_t auto_reload;    /**&lt; Auto-reload flag */&#10;} SysTick_Timer_t;&#10;&#10;/**&#10; * @brief Initialize a software timer&#10; * &#10; * @param timer Pointer to timer structure&#10; * @param interval_ms Timer interval in milliseconds&#10; * @param auto_reload 1 for auto-reload, 0 for one-shot&#10; */&#10;void systick_timer_init(SysTick_Timer_t *timer, uint32_t interval_ms, uint8_t auto_reload);&#10;&#10;/**&#10; * @brief Start a software timer&#10; * &#10; * @param timer Pointer to timer structure&#10; */&#10;void systick_timer_start(SysTick_Timer_t *timer);&#10;&#10;/**&#10; * @brief Stop a software timer&#10; * &#10; * @param timer Pointer to timer structure&#10; */&#10;void systick_timer_stop(SysTick_Timer_t *timer);&#10;&#10;/**&#10; * @brief Check if software timer has expired&#10; * &#10; * @param timer Pointer to timer structure&#10; * @return uint8_t 1 if timer expired, 0 otherwise&#10; */&#10;uint8_t systick_timer_expired(SysTick_Timer_t *timer);&#10;&#10;/**&#10; * @brief Reset software timer&#10; * &#10; * @param timer Pointer to timer structure&#10; */&#10;void systick_timer_reset(SysTick_Timer_t *timer);&#10;&#10;/** @} */&#10;&#10;/**&#10; * @name Performance Measurement Functions&#10; * @{&#10; */&#10;&#10;/**&#10; * @brief Start performance measurement&#10; * &#10; * @return uint32_t Start time marker&#10; */&#10;uint32_t systick_perf_start(void);&#10;&#10;/**&#10; * @brief End performance measurement and get elapsed time&#10; * &#10; * @param start_time Start time marker from systick_perf_start()&#10; * @return uint32_t Elapsed time in microseconds&#10; */&#10;uint32_t systick_perf_end(uint32_t start_time);&#10;&#10;/** @} */&#10;&#10;/**&#10; * @name Watchdog and Heartbeat Functions&#10; * @{&#10; */&#10;&#10;/**&#10; * @brief Simple heartbeat LED toggle&#10; * &#10; * @param led_port GPIO port for heartbeat LED&#10; * @param led_pin GPIO pin for heartbeat LED&#10; * @param interval_ms Heartbeat interval in milliseconds&#10; */&#10;void systick_heartbeat(GPIO_TypeDef *led_port, uint8_t led_pin, uint32_t interval_ms);&#10;&#10;/**&#10; * @brief Software watchdog timer&#10; * &#10; * @param timeout_ms Watchdog timeout in milliseconds&#10; * @return uint8_t 1 if watchdog expired, 0 otherwise&#10; */&#10;uint8_t systick_watchdog_check(uint32_t timeout_ms);&#10;&#10;/**&#10; * @brief Reset software watchdog timer&#10; */&#10;void systick_watchdog_reset(void);&#10;&#10;/** @} */&#10;&#10;/**&#10; * @name Time Conversion Utilities&#10; * @{&#10; */&#10;&#10;/**&#10; * @brief Convert milliseconds to system ticks&#10; * &#10; * @param ms Time in milliseconds&#10; * @return uint32_t Equivalent system ticks&#10; */&#10;uint32_t systick_ms_to_ticks(uint32_t ms);&#10;&#10;/**&#10; * @brief Convert system ticks to milliseconds&#10; * &#10; * @param ticks System ticks&#10; * @return uint32_t Equivalent time in milliseconds&#10; */&#10;uint32_t systick_ticks_to_ms(uint32_t ticks);&#10;&#10;/**&#10; * @brief Get system uptime in seconds&#10; * &#10; * @return uint32_t System uptime in seconds&#10; */&#10;uint32_t systick_get_uptime_seconds(void);&#10;&#10;/**&#10; * @brief Convert uptime to hours:minutes:seconds format&#10; * &#10; * @param hours Pointer to store hours&#10; * @param minutes Pointer to store minutes  &#10; * @param seconds Pointer to store seconds&#10; */&#10;void systick_get_uptime_hms(uint32_t *hours, uint32_t *minutes, uint32_t *seconds);&#10;&#10;/** @} */&#10;&#10;/**&#10; * @name Advanced Timing Functions&#10; * @{&#10; */&#10;&#10;/**&#10; * @brief Task scheduler structure&#10; */&#10;typedef struct {&#10;    void (*task_function)(void);    /**&lt; Function pointer to task */&#10;    uint32_t interval_ms;           /**&lt; Task execution interval */&#10;    uint32_t last_execution;        /**&lt; Last execution time */&#10;    uint8_t enabled;                /**&lt; Task enabled flag */&#10;} SysTick_Task_t;&#10;&#10;/**&#10; * @brief Initialize task scheduler&#10; * &#10; * @param task Pointer to task structure&#10; * @param function Function to execute&#10; * @param interval_ms Execution interval in milliseconds&#10; */&#10;void systick_task_init(SysTick_Task_t *task, void (*function)(void), uint32_t interval_ms);&#10;&#10;/**&#10; * @brief Run task scheduler (call in main loop)&#10; * &#10; * @param task Pointer to task structure&#10; */&#10;void systick_task_run(SysTick_Task_t *task);&#10;&#10;/**&#10; * @brief Enable/disable task&#10; * &#10; * @param task Pointer to task structure&#10; * @param enabled 1 to enable, 0 to disable&#10; */&#10;void systick_task_enable(SysTick_Task_t *task, uint8_t enabled);&#10;&#10;/** @} */&#10;&#10;#endif /* SYSTICK_FUNCTIONS_H */" />
              <option name="updatedContent" value="/**&#10; ******************************************************************************&#10; * @file           : systick.h&#10; * @author         : Haoyi Chen&#10; * @date           : 2025-08-10&#10; * @brief          : SysTick timer functions for timing and delay operations&#10; ******************************************************************************&#10; * @details&#10; * This file provides essential SysTick timer functions for embedded systems,&#10; * including time keeping, blocking/non-blocking delays, and simple timer&#10; * utilities. Designed for bare-metal STM32F407VGT6 applications.&#10; *&#10; * Common usage patterns:&#10; * - System time keeping with 1ms resolution&#10; * - Blocking delays for simple timing needs&#10; * - Non-blocking timing for main loop operations&#10; * - Simple software timers for periodic tasks&#10; ******************************************************************************&#10; */&#10;&#10;#ifndef SYSTICK_H&#10;#define SYSTICK_H&#10;&#10;#include &quot;stm32f407xx.h&quot;&#10;#include &lt;stdint.h&gt;&#10;&#10;/* Global system tick counters (volatile for interrupt access) */&#10;extern volatile uint32_t system_tick_ms;&#10;&#10;/**&#10; * @name SysTick Configuration Constants&#10; * @{&#10; */&#10;#define SYSTICK_FREQUENCY_HZ    1000    /**&lt; SysTick frequency: 1kHz = 1ms interrupts */&#10;/** @} */&#10;&#10;/**&#10; * @name Core SysTick Functions&#10; * @{&#10; */&#10;&#10;/**&#10; * @brief Initialize SysTick timer for 1ms interrupts&#10; * &#10; * @details Configures SysTick to generate interrupts every 1ms using the&#10; *          processor clock. This is the most common configuration for&#10; *          system timing in embedded applications.&#10; * &#10; * @param system_clock_hz System clock frequency in Hz (e.g., 168000000 for 168MHz)&#10; * @return uint8_t 0 if successful, 1 if reload value exceeds 24-bit limit&#10; * &#10; * @note Maximum supported clock frequency is ~16.7MHz due to 24-bit reload register&#10; * @warning Call this function before enabling interrupts&#10; */&#10;uint8_t systick_init(uint32_t system_clock_hz);&#10;&#10;/**&#10; * @brief SysTick interrupt handler&#10; * &#10; * @details Must be called from SysTick_Handler() in interrupt vector.&#10; *          Increments the global millisecond counter.&#10; * &#10; * @note This function should be called every 1ms when SysTick interrupt occurs&#10; */&#10;void systick_irq_handler(void);&#10;&#10;/** @} */&#10;&#10;/**&#10; * @name Time Keeping Functions&#10; * @{&#10; */&#10;&#10;/**&#10; * @brief Get current system time in milliseconds&#10; * &#10; * @details Returns the number of milliseconds since system initialization.&#10; *          Rolls over approximately every 49.7 days.&#10; * &#10; * @return uint32_t Current system time in milliseconds&#10; * &#10; * @note This function is interrupt-safe and can be called from any context&#10; */&#10;uint32_t systick_get_ms(void);&#10;&#10;/**&#10; * @brief Calculate elapsed time since a reference point&#10; * &#10; * @details Calculates time difference handling 32-bit counter rollover.&#10; *          Useful for measuring time intervals up to ~49 days.&#10; * &#10; * @param start_time_ms Reference time obtained from systick_get_ms()&#10; * @return uint32_t Elapsed time in milliseconds&#10; * &#10; * @note Handles counter overflow correctly&#10; */&#10;uint32_t systick_elapsed_ms(uint32_t start_time_ms);&#10;&#10;/** @} */&#10;&#10;/**&#10; * @name Delay Functions&#10; * @{&#10; */&#10;&#10;/**&#10; * @brief Blocking delay in milliseconds&#10; * &#10; * @details Blocks execution for the specified time period.&#10; *          Uses CPU polling, so other interrupts can still execute.&#10; * &#10; * @param delay_ms Delay duration in milliseconds&#10; * &#10; * @warning Blocking function - use sparingly in main application&#10; * @note Accuracy depends on SysTick interrupt timing (±1ms typical)&#10; */&#10;void systick_delay_ms(uint32_t delay_ms);&#10;&#10;/**&#10; * @brief Check if a delay period has elapsed (non-blocking)&#10; * &#10; * @details Non-blocking function to check if a specified time has passed&#10; *          since a reference point. Ideal for main loop timing.&#10; * &#10; * @param start_time_ms Reference time from systick_get_ms()&#10; * @param delay_ms Desired delay period in milliseconds&#10; * @return uint8_t 1 if delay period has elapsed, 0 otherwise&#10; * &#10; * @note Preferred method for timing in main application loops&#10; */&#10;uint8_t systick_delay_elapsed(uint32_t start_time_ms, uint32_t delay_ms);&#10;&#10;/** @} */&#10;&#10;/**&#10; * @name Simple Timer Utilities&#10; * @{&#10; */&#10;&#10;/**&#10; * @brief Simple software timer structure&#10; * &#10; * @details Lightweight timer for non-blocking periodic operations.&#10; *          Suitable for tasks like LED blinking, sensor reading, etc.&#10; */&#10;typedef struct {&#10;    uint32_t start_time;    /**&lt; Timer start time in milliseconds */&#10;    uint32_t interval;      /**&lt; Timer interval in milliseconds */&#10;    uint8_t enabled;        /**&lt; Timer enabled flag: 1=active, 0=stopped */&#10;    uint8_t auto_reload;    /**&lt; Auto-reload mode: 1=continuous, 0=one-shot */&#10;} SysTick_Timer_t;&#10;&#10;/**&#10; * @brief Initialize a software timer&#10; * &#10; * @details Sets up a timer structure with specified interval and mode.&#10; *          Timer is created in stopped state.&#10; * &#10; * @param timer Pointer to timer structure&#10; * @param interval_ms Timer period in milliseconds&#10; * @param auto_reload 1 for continuous timer, 0 for one-shot&#10; * &#10; * @note Timer must be started with systick_timer_start() to begin counting&#10; */&#10;void systick_timer_init(SysTick_Timer_t *timer, uint32_t interval_ms, uint8_t auto_reload);&#10;&#10;/**&#10; * @brief Start a software timer&#10; * &#10; * @details Starts timer counting from current system time.&#10; *          Can be used to restart an expired timer.&#10; * &#10; * @param timer Pointer to initialized timer structure&#10; */&#10;void systick_timer_start(SysTick_Timer_t *timer);&#10;&#10;/**&#10; * @brief Check if software timer has expired&#10; * &#10; * @details Checks timer expiration and handles auto-reload if enabled.&#10; *          Call this function periodically in main loop.&#10; * &#10; * @param timer Pointer to timer structure&#10; * @return uint8_t 1 if timer expired, 0 if still counting&#10; * &#10; * @note Auto-reload timers restart automatically when expired&#10; * @note One-shot timers stop automatically when expired&#10; */&#10;uint8_t systick_timer_expired(SysTick_Timer_t *timer);&#10;&#10;/** @} */&#10;&#10;#endif /* SYSTICK_H */&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Src/i2c.c">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Src/i2c.c" />
              <option name="updatedContent" value="// filepath: /Users/haoyi/Documents/Code/Electronics_for_embedded_systems/Motor_monitor/Software/Src/i2c.c&#10;/**&#10; * @file i2c.c&#10; * @author Haoyi Chen&#10; * @date 2025-08-08&#10; * @brief STM32F4 I2C register-level driver&#10; *&#10; * @details This file provides basic I2C initialization, transmit, receive and memory access&#10; * functions for STM32F407 series microcontrollers. All operations are performed at the&#10; * register level, without using HAL or LL libraries.&#10; *&#10; * Created for personal learning and embedded systems experimentation.&#10; */&#10;&#10;#include &quot;i2c.h&quot;&#10;#include &quot;gpio.h&quot;&#10;&#10;/**&#10; * @brief Initialize I2C with the specified parameters&#10; * &#10; * @details Configures I2C by setting clock speed, addressing mode, duty cycle and other parameters&#10; *&#10; * @param I2Cx I2C instance (I2C1, I2C2, or I2C3)&#10; * @param init Pointer to I2C initialization structure&#10; * &#10; * @note I2C clock must be enabled separately via RCC registers before calling this function&#10; */&#10;void i2c_init(I2C_TypeDef *I2Cx, I2C_InitTypeDef *init) {&#10;    uint32_t pclk1 = 0;&#10;    uint32_t freqrange = 0;&#10;    &#10;    /* Disable I2C first */&#10;    I2Cx-&gt;CR1 &amp;= ~I2C_CR1_PE;&#10;    &#10;    /* Get PCLK1 frequency */&#10;    // Assuming a function like this exists in your RCC module&#10;    // In real implementation, you should use your own RCC function&#10;    // pclk1 = rcc_get_pclk1_freq();&#10;    &#10;    // For now, using a fixed value - this should be replaced with actual PCLK1 frequency&#10;    pclk1 = 42000000; // 42 MHz (typical PCLK1 for STM32F407 at maximum speed)&#10;    &#10;    /* I2C peripheral configuration */&#10;    &#10;    /* Configure I2C CR2 register: frequency */&#10;    freqrange = (uint32_t)(pclk1 / 1000000);&#10;    I2Cx-&gt;CR2 = freqrange; // PCLK1 frequency in MHz&#10;    &#10;    /* Configure I2C CCR register: Clock control */&#10;    I2Cx-&gt;CCR = 0; // Clear CCR register&#10;    &#10;    /* Configure speed in standard mode */&#10;    if (init-&gt;ClockSpeed &lt;= 100000) {&#10;        /* Standard mode speed calculation */&#10;        I2Cx-&gt;CCR |= (uint16_t)((pclk1 / (init-&gt;ClockSpeed * 2)));&#10;        &#10;        /* Set maximum rise time in standard mode */&#10;        I2Cx-&gt;TRISE = freqrange + 1;&#10;    }&#10;    /* Configure speed in fast mode */&#10;    else {&#10;        /* Fast mode speed calculation */&#10;        &#10;        /* Configure duty cycle */&#10;        I2Cx-&gt;CCR |= init-&gt;DutyCycle;&#10;        &#10;        /* Set FAST mode bit */&#10;        I2Cx-&gt;CCR |= I2C_CCR_FS;&#10;        &#10;        /* Fast mode speed calculation based on duty cycle */&#10;        if (init-&gt;DutyCycle == I2C_DUTYCYCLE_2) {&#10;            I2Cx-&gt;CCR |= (uint16_t)(pclk1 / (init-&gt;ClockSpeed * 3));&#10;        }&#10;        else { // I2C_DUTYCYCLE_16_9&#10;            I2Cx-&gt;CCR |= (uint16_t)(pclk1 / (init-&gt;ClockSpeed * 25));&#10;        }&#10;        &#10;        /* Set maximum rise time in fast mode */&#10;        I2Cx-&gt;TRISE = (uint16_t)((freqrange * 300) / 1000) + 1;&#10;    }&#10;    &#10;    /* Configure I2C OAR1 register: Own Address 1 */&#10;    I2Cx-&gt;OAR1 = (init-&gt;AddressingMode | (init-&gt;OwnAddress1 &lt;&lt; 1));&#10;    &#10;    /* Configure I2C OAR2 register: Dual mode and Own Address 2 */&#10;    I2Cx-&gt;OAR2 = (init-&gt;DualAddressMode | (init-&gt;OwnAddress2 &lt;&lt; 1));&#10;    &#10;    /* Configure I2C CR1 register */&#10;    I2Cx-&gt;CR1 |= (init-&gt;GeneralCallMode | init-&gt;NoStretchMode);&#10;    &#10;    /* Enable I2C */&#10;    I2Cx-&gt;CR1 |= I2C_CR1_PE;&#10;}&#10;&#10;/**&#10; * @brief Initialize GPIO pins for I2C&#10; * &#10; * @details Configures GPIO pins in alternate function open-drain mode for SCL and SDA&#10; *&#10; * @param I2Cx I2C instance (I2C1, I2C2, or I2C3)&#10; * @param GPIOx GPIO port for SCL and SDA pins (GPIOA, GPIOB, etc.)&#10; * @param SCL_Pin SCL pin number (0-15)&#10; * @param SDA_Pin SDA pin number (0-15)&#10; * &#10; * @note GPIO clock must be enabled separately via RCC registers&#10; */&#10;void i2c_gpio_init(I2C_TypeDef *I2Cx, GPIO_TypeDef *GPIOx, uint8_t SCL_Pin, uint8_t SDA_Pin) {&#10;    uint8_t alternate_function;&#10;    &#10;    /* Determine alternate function number based on I2C instance */&#10;    if (I2Cx == I2C1 || I2Cx == I2C2) {&#10;        alternate_function = 4; // AF4 for I2C1 and I2C2&#10;    } else {&#10;        alternate_function = 9; // AF9 for I2C3&#10;    }&#10;    &#10;    /* Configure SCL pin: Alternate function Open-Drain */&#10;    gpio_init(GPIOx, SCL_Pin, 0x02, 0x01, 0x03, 0x00); // AF mode, open drain, high speed, no pull&#10;    gpio_set_alternate_function(GPIOx, SCL_Pin, alternate_function);&#10;    &#10;    /* Configure SDA pin: Alternate function Open-Drain */&#10;    gpio_init(GPIOx, SDA_Pin, 0x02, 0x01, 0x03, 0x00); // AF mode, open drain, high speed, no pull&#10;    gpio_set_alternate_function(GPIOx, SDA_Pin, alternate_function);&#10;}&#10;&#10;/**&#10; * @brief Check if the I2C bus is free&#10; * &#10; * @details Reads the BUSY bit in SR2 register to determine if the bus is busy&#10; * &#10; * @param I2Cx I2C instance (I2C1, I2C2, or I2C3)&#10; * @return uint8_t 1 if bus is free, 0 if busy&#10; */&#10;uint8_t i2c_is_bus_free(I2C_TypeDef *I2Cx) {&#10;    /* Check if the bus is busy */&#10;    if ((I2Cx-&gt;SR2 &amp; I2C_FLAG_BUSY) == I2C_FLAG_BUSY) {&#10;        return 0; // Bus is busy&#10;    }&#10;    return 1; // Bus is free&#10;}&#10;&#10;/**&#10; * @brief Wait for a specific I2C flag to be set or reset&#10; * &#10; * @details Waits for a flag in SR1 or SR2 register to reach expected state with timeout&#10; * &#10; * @param I2Cx I2C instance (I2C1, I2C2, or I2C3)&#10; * @param flag Flag to check&#10; * @param status Expected status (1 for set, 0 for reset)&#10; * @param timeout Timeout value&#10; * @return uint8_t 0 if successful (flag matched expected state), 1 if timeout&#10; */&#10;uint8_t i2c_wait_flag(I2C_TypeDef *I2Cx, uint32_t flag, uint8_t status, uint32_t timeout) {&#10;    uint32_t tickstart = 0;&#10;    &#10;    /* Get current tick count */&#10;    // Assuming a millisecond tick counter exists&#10;    tickstart = 0; // Replace with actual tick counter&#10;    &#10;    /* Flag is in SR2 register */&#10;    if (flag &gt; 0xFFFF) {&#10;        while ((((I2Cx-&gt;SR2 &amp; (flag &amp; 0xFFFF)) == (flag &amp; 0xFFFF)) ? 1 : 0) != status) {&#10;            /* Check for timeout */&#10;            if (timeout != 0 &amp;&amp; ((0 - tickstart) &gt; timeout)) { // Replace with actual tick calculation&#10;                return 1; // Timeout&#10;            }&#10;        }&#10;    }&#10;    /* Flag is in SR1 register */&#10;    else {&#10;        while ((((I2Cx-&gt;SR1 &amp; flag) == flag) ? 1 : 0) != status) {&#10;            /* Check for timeout */&#10;            if (timeout != 0 &amp;&amp; ((0 - tickstart) &gt; timeout)) { // Replace with actual tick calculation&#10;                return 1; // Timeout&#10;            }&#10;        }&#10;    }&#10;    &#10;    return 0; // Flag matched expected state&#10;}&#10;&#10;/**&#10; * @brief Generate start condition on I2C bus&#10; * &#10; * @details Sets START bit in CR1 register and waits for SB bit to be set&#10; * &#10; * @param I2Cx I2C instance (I2C1, I2C2, or I2C3)&#10; * @return uint8_t 0 if successful, 1 if error&#10; */&#10;uint8_t i2c_generate_start(I2C_TypeDef *I2Cx) {&#10;    /* Generate start condition */&#10;    I2Cx-&gt;CR1 |= I2C_CR1_START;&#10;    &#10;    /* Wait until SB flag is set */&#10;    if (i2c_wait_flag(I2Cx, I2C_FLAG_SB, 1, I2C_TIMEOUT_FLAG) != 0) {&#10;        return 1; // Error&#10;    }&#10;    &#10;    return 0; // Success&#10;}&#10;&#10;/**&#10; * @brief Generate stop condition on I2C bus&#10; * &#10; * @details Sets STOP bit in CR1 register&#10; * &#10; * @param I2Cx I2C instance (I2C1, I2C2, or I2C3)&#10; * @return uint8_t 0 if successful, 1 if error&#10; */&#10;uint8_t i2c_generate_stop(I2C_TypeDef *I2Cx) {&#10;    /* Generate stop condition */&#10;    I2Cx-&gt;CR1 |= I2C_CR1_STOP;&#10;    &#10;    return 0; // Success&#10;}&#10;&#10;/**&#10; * @brief Send 7-bit or 10-bit device address&#10; * &#10; * @details Sends device address with R/W bit according to direction&#10; * &#10; * @param I2Cx I2C instance (I2C1, I2C2, or I2C3)&#10; * @param DevAddress Target device address&#10; * @param Direction Direction (I2C_DIRECTION_TRANSMIT or I2C_DIRECTION_RECEIVE)&#10; * @return uint8_t 0 if successful, 1 if error&#10; */&#10;uint8_t i2c_send_address(I2C_TypeDef *I2Cx, uint16_t DevAddress, uint8_t Direction) {&#10;    /* 7-bit addressing mode */&#10;    if ((I2Cx-&gt;OAR1 &amp; I2C_OAR1_ADDMODE) == 0) {&#10;        /* Send slave address with R/W bit */&#10;        I2Cx-&gt;DR = (uint8_t)((DevAddress &lt;&lt; 1) | Direction);&#10;    }&#10;    /* 10-bit addressing mode */&#10;    else {&#10;        /* Send header for 10-bit addressing */&#10;        I2Cx-&gt;DR = (uint8_t)(((DevAddress &gt;&gt; 7) &lt;&lt; 1) | 0xF0);&#10;        &#10;        /* Wait until ADD10 flag is set */&#10;        if (i2c_wait_flag(I2Cx, I2C_FLAG_ADD10, 1, I2C_TIMEOUT_FLAG) != 0) {&#10;            return 1; // Error&#10;        }&#10;        &#10;        /* Send slave address (2nd part) */&#10;        I2Cx-&gt;DR = (uint8_t)(DevAddress &amp; 0xFF);&#10;        &#10;        /* If direction is receive, generate repeated START condition */&#10;        if (Direction == I2C_DIRECTION_RECEIVE) {&#10;            /* Wait until ADDR flag is set */&#10;            if (i2c_wait_flag(I2Cx, I2C_FLAG_ADDR, 1, I2C_TIMEOUT_FLAG) != 0) {&#10;                return 1; // Error&#10;            }&#10;            &#10;            /* Clear ADDR flag */&#10;            __IO uint32_t tmp = I2Cx-&gt;SR2;&#10;            (void)tmp;&#10;            &#10;            /* Generate repeated start condition */&#10;            I2Cx-&gt;CR1 |= I2C_CR1_START;&#10;            &#10;            /* Wait until SB flag is set */&#10;            if (i2c_wait_flag(I2Cx, I2C_FLAG_SB, 1, I2C_TIMEOUT_FLAG) != 0) {&#10;                return 1; // Error&#10;            }&#10;            &#10;            /* Send header for 10-bit addressing (with READ bit) */&#10;            I2Cx-&gt;DR = (uint8_t)(((DevAddress &gt;&gt; 7) &lt;&lt; 1) | 0xF1);&#10;        }&#10;    }&#10;    &#10;    /* Wait until ADDR flag is set */&#10;    if (i2c_wait_flag(I2Cx, I2C_FLAG_ADDR, 1, I2C_TIMEOUT_FLAG) != 0) {&#10;        return 1; // Error&#10;    }&#10;    &#10;    /* Clear ADDR flag */&#10;    __IO uint32_t tmp = I2Cx-&gt;SR1;&#10;    tmp = I2Cx-&gt;SR2; // Read SR1 then SR2 to clear ADDR flag&#10;    (void)tmp;&#10;    &#10;    return 0; // Success&#10;}&#10;&#10;/**&#10; * @brief Master transmit data to a slave device&#10; * &#10; * @details Initiates transmission with START condition, sends data bytes, and generates STOP&#10; * &#10; * @param I2Cx I2C instance (I2C1, I2C2, or I2C3)&#10; * @param DevAddress Target device address&#10; * @param pData Pointer to data buffer&#10; * @param Size Amount of data to be sent&#10; * @param Timeout Timeout value&#10; * @return uint8_t 0 if successful, 1 if error&#10; */&#10;uint8_t i2c_master_transmit(I2C_TypeDef *I2Cx, uint16_t DevAddress, uint8_t *pData, uint16_t Size, uint32_t Timeout) {&#10;    /* Check parameters */&#10;    if (Size == 0 || pData == NULL) {&#10;        return 1; // Error: Invalid parameters&#10;    }&#10;    &#10;    /* Wait until bus is free */&#10;    if (i2c_wait_flag(I2Cx, I2C_FLAG_BUSY, 0, I2C_TIMEOUT_BUSY_FLAG) != 0) {&#10;        return 1; // Error: Bus is busy&#10;    }&#10;    &#10;    /* Generate START condition */&#10;    if (i2c_generate_start(I2Cx) != 0) {&#10;        return 1; // Error generating START&#10;    }&#10;    &#10;    /* Send slave address (for write) */&#10;    if (i2c_send_address(I2Cx, DevAddress, I2C_DIRECTION_TRANSMIT) != 0) {&#10;        i2c_generate_stop(I2Cx);&#10;        return 1; // Error sending address&#10;    }&#10;    &#10;    /* Send data */&#10;    while (Size &gt; 0) {&#10;        /* Wait until TXE flag is set */&#10;        if (i2c_wait_flag(I2Cx, I2C_FLAG_TXE, 1, Timeout) != 0) {&#10;            i2c_generate_stop(I2Cx);&#10;            return 1; // Error: TXE timeout&#10;        }&#10;        &#10;        /* Write data to DR */&#10;        I2Cx-&gt;DR = *pData;&#10;        pData++;&#10;        Size--;&#10;        &#10;        /* Wait until BTF flag is set for last byte */&#10;        if (Size == 0) {&#10;            if (i2c_wait_flag(I2Cx, I2C_FLAG_BTF, 1, Timeout) != 0) {&#10;                i2c_generate_stop(I2Cx);&#10;                return 1; // Error: BTF timeout&#10;            }&#10;        }&#10;    }&#10;    &#10;    /* Generate STOP condition */&#10;    i2c_generate_stop(I2Cx);&#10;    &#10;    return 0; // Success&#10;}&#10;&#10;/**&#10; * @brief Master receive data from a slave device&#10; * &#10; * @details Initiates reception with START condition, receives data bytes, and generates STOP&#10; * &#10; * @param I2Cx I2C instance (I2C1, I2C2, or I2C3)&#10; * @param DevAddress Target device address&#10; * @param pData Pointer to data buffer&#10; * @param Size Amount of data to be received&#10; * @param Timeout Timeout value&#10; * @return uint8_t 0 if successful, 1 if error&#10; */&#10;uint8_t i2c_master_receive(I2C_TypeDef *I2Cx, uint16_t DevAddress, uint8_t *pData, uint16_t Size, uint32_t Timeout) {&#10;    /* Check parameters */&#10;    if (Size == 0 || pData == NULL) {&#10;        return 1; // Error: Invalid parameters&#10;    }&#10;    &#10;    /* Wait until bus is free */&#10;    if (i2c_wait_flag(I2Cx, I2C_FLAG_BUSY, 0, I2C_TIMEOUT_BUSY_FLAG) != 0) {&#10;        return 1; // Error: Bus is busy&#10;    }&#10;    &#10;    /* Enable Acknowledge */&#10;    I2Cx-&gt;CR1 |= I2C_CR1_ACK;&#10;    &#10;    /* Generate START condition */&#10;    if (i2c_generate_start(I2Cx) != 0) {&#10;        return 1; // Error generating START&#10;    }&#10;    &#10;    /* Send slave address (for read) */&#10;    if (i2c_send_address(I2Cx, DevAddress, I2C_DIRECTION_RECEIVE) != 0) {&#10;        i2c_generate_stop(I2Cx);&#10;        return 1; // Error sending address&#10;    }&#10;    &#10;    /* Receive data */&#10;    if (Size == 1) {&#10;        /* Disable Acknowledge */&#10;        I2Cx-&gt;CR1 &amp;= ~I2C_CR1_ACK;&#10;        &#10;        /* Generate STOP condition */&#10;        i2c_generate_stop(I2Cx);&#10;        &#10;        /* Wait until RXNE flag is set */&#10;        if (i2c_wait_flag(I2Cx, I2C_FLAG_RXNE, 1, Timeout) != 0) {&#10;            return 1; // Error: RXNE timeout&#10;        }&#10;        &#10;        /* Read data from DR */&#10;        *pData = (uint8_t)I2Cx-&gt;DR;&#10;    }&#10;    else if (Size == 2) {&#10;        /* Enable POS */&#10;        I2Cx-&gt;CR1 |= I2C_CR1_POS;&#10;        &#10;        /* Clear ADDR flag */&#10;        __IO uint32_t tmp = I2Cx-&gt;SR1;&#10;        tmp = I2Cx-&gt;SR2;&#10;        (void)tmp;&#10;        &#10;        /* Disable Acknowledge */&#10;        I2Cx-&gt;CR1 &amp;= ~I2C_CR1_ACK;&#10;        &#10;        /* Wait until BTF flag is set */&#10;        if (i2c_wait_flag(I2Cx, I2C_FLAG_BTF, 1, Timeout) != 0) {&#10;            return 1; // Error: BTF timeout&#10;        }&#10;        &#10;        /* Generate STOP condition */&#10;        i2c_generate_stop(I2Cx);&#10;        &#10;        /* Read data from DR */&#10;        *pData = (uint8_t)I2Cx-&gt;DR;&#10;        pData++;&#10;        *pData = (uint8_t)I2Cx-&gt;DR;&#10;    }&#10;    else {&#10;        /* Clear ADDR flag */&#10;        __IO uint32_t tmp = I2Cx-&gt;SR1;&#10;        tmp = I2Cx-&gt;SR2;&#10;        (void)tmp;&#10;        &#10;        while (Size &gt; 3) {&#10;            /* Wait until RXNE flag is set */&#10;            if (i2c_wait_flag(I2Cx, I2C_FLAG_RXNE, 1, Timeout) != 0) {&#10;                i2c_generate_stop(I2Cx);&#10;                return 1; // Error: RXNE timeout&#10;            }&#10;            &#10;            /* Read data from DR */&#10;            *pData = (uint8_t)I2Cx-&gt;DR;&#10;            pData++;&#10;            Size--;&#10;        }&#10;        &#10;        /* When remaining bytes = 3 */&#10;        /* Wait until BTF flag is set */&#10;        if (i2c_wait_flag(I2Cx, I2C_FLAG_BTF, 1, Timeout) != 0) {&#10;            i2c_generate_stop(I2Cx);&#10;            return 1; // Error: BTF timeout&#10;        }&#10;        &#10;        /* Disable Acknowledge */&#10;        I2Cx-&gt;CR1 &amp;= ~I2C_CR1_ACK;&#10;        &#10;        /* Read data N-2 */&#10;        *pData = (uint8_t)I2Cx-&gt;DR;&#10;        pData++;&#10;        &#10;        /* Wait until BTF flag is set */&#10;        if (i2c_wait_flag(I2Cx, I2C_FLAG_BTF, 1, Timeout) != 0) {&#10;            i2c_generate_stop(I2Cx);&#10;            return 1; // Error: BTF timeout&#10;        }&#10;        &#10;        /* Generate STOP condition */&#10;        i2c_generate_stop(I2Cx);&#10;        &#10;        /* Read data N-1 */&#10;        *pData = (uint8_t)I2Cx-&gt;DR;&#10;        pData++;&#10;        &#10;        /* Read data N */&#10;        *pData = (uint8_t)I2Cx-&gt;DR;&#10;    }&#10;    &#10;    /* Reset POS bit */&#10;    I2Cx-&gt;CR1 &amp;= ~I2C_CR1_POS;&#10;    &#10;    return 0; // Success&#10;}&#10;&#10;/**&#10; * @brief Write to a memory address of an I2C slave device&#10; * &#10; * @details Sends device address, memory address, and data to write to that address&#10; * &#10; * @param I2Cx I2C instance (I2C1, I2C2, or I2C3)&#10; * @param DevAddress Target device address&#10; * @param MemAddress Internal memory address&#10; * @param MemAddSize Size of memory address (I2C_MEMADD_SIZE_8BIT or I2C_MEMADD_SIZE_16BIT)&#10; * @param pData Pointer to data buffer&#10; * @param Size Amount of data to be sent&#10; * @param Timeout Timeout value&#10; * @return uint8_t 0 if successful, 1 if error&#10; */&#10;uint8_t i2c_mem_write(I2C_TypeDef *I2Cx, uint16_t DevAddress, uint16_t MemAddress, &#10;                      uint8_t MemAddSize, uint8_t *pData, uint16_t Size, uint32_t Timeout) {&#10;    /* Check parameters */&#10;    if (Size == 0 || pData == NULL) {&#10;        return 1; // Error: Invalid parameters&#10;    }&#10;    &#10;    /* Wait until bus is free */&#10;    if (i2c_wait_flag(I2Cx, I2C_FLAG_BUSY, 0, I2C_TIMEOUT_BUSY_FLAG) != 0) {&#10;        return 1; // Error: Bus is busy&#10;    }&#10;    &#10;    /* Generate START condition */&#10;    if (i2c_generate_start(I2Cx) != 0) {&#10;        return 1; // Error generating START&#10;    }&#10;    &#10;    /* Send slave address (for write) */&#10;    if (i2c_send_address(I2Cx, DevAddress, I2C_DIRECTION_TRANSMIT) != 0) {&#10;        i2c_generate_stop(I2Cx);&#10;        return 1; // Error sending address&#10;    }&#10;    &#10;    /* Send memory address */&#10;    if (MemAddSize == I2C_MEMADD_SIZE_8BIT) {&#10;        /* Send 8-bit memory address */&#10;        I2Cx-&gt;DR = (uint8_t)(MemAddress &amp; 0xFF);&#10;        &#10;        /* Wait until TXE flag is set */&#10;        if (i2c_wait_flag(I2Cx, I2C_FLAG_TXE, 1, Timeout) != 0) {&#10;            i2c_generate_stop(I2Cx);&#10;            return 1; // Error: TXE timeout&#10;        }&#10;    }&#10;    else { // I2C_MEMADD_SIZE_16BIT&#10;        /* Send MSB of 16-bit memory address */&#10;        I2Cx-&gt;DR = (uint8_t)((MemAddress &gt;&gt; 8) &amp; 0xFF);&#10;        &#10;        /* Wait until TXE flag is set */&#10;        if (i2c_wait_flag(I2Cx, I2C_FLAG_TXE, 1, Timeout) != 0) {&#10;            i2c_generate_stop(I2Cx);&#10;            return 1; // Error: TXE timeout&#10;        }&#10;        &#10;        /* Send LSB of 16-bit memory address */&#10;        I2Cx-&gt;DR = (uint8_t)(MemAddress &amp; 0xFF);&#10;        &#10;        /* Wait until TXE flag is set */&#10;        if (i2c_wait_flag(I2Cx, I2C_FLAG_TXE, 1, Timeout) != 0) {&#10;            i2c_generate_stop(I2Cx);&#10;            return 1; // Error: TXE timeout&#10;        }&#10;    }&#10;    &#10;    /* Send data */&#10;    while (Size &gt; 0) {&#10;        /* Wait until TXE flag is set */&#10;        if (i2c_wait_flag(I2Cx, I2C_FLAG_TXE, 1, Timeout) != 0) {&#10;            i2c_generate_stop(I2Cx);&#10;            return 1; // Error: TXE timeout&#10;        }&#10;        &#10;        /* Write data to DR */&#10;        I2Cx-&gt;DR = *pData;&#10;        pData++;&#10;        Size--;&#10;        &#10;        /* Wait until BTF flag is set for last byte */&#10;        if (Size == 0) {&#10;            if (i2c_wait_flag(I2Cx, I2C_FLAG_BTF, 1, Timeout) != 0) {&#10;                i2c_generate_stop(I2Cx);&#10;                return 1; // Error: BTF timeout&#10;            }&#10;        }&#10;    }&#10;    &#10;    /* Generate STOP condition */&#10;    i2c_generate_stop(I2Cx);&#10;    &#10;    return 0; // Success&#10;}&#10;&#10;/**&#10; * @brief Read from a memory address of an I2C slave device&#10; * &#10; * @details Sends device address and memory address, then reads data from that address&#10; * &#10; * @param I2Cx I2C instance (I2C1, I2C2, or I2C3)&#10; * @param DevAddress Target device address&#10; * @param MemAddress Internal memory address&#10; * @param MemAddSize Size of memory address (I2C_MEMADD_SIZE_8BIT or I2C_MEMADD_SIZE_16BIT)&#10; * @param pData Pointer to data buffer&#10; * @param Size Amount of data to be read&#10; * @param Timeout Timeout value&#10; * @return uint8_t 0 if successful, 1 if error&#10; */&#10;uint8_t i2c_mem_read(I2C_TypeDef *I2Cx, uint16_t DevAddress, uint16_t MemAddress, &#10;                     uint8_t MemAddSize, uint8_t *pData, uint16_t Size, uint32_t Timeout) {&#10;    /* Check parameters */&#10;    if (Size == 0 || pData == NULL) {&#10;        return 1; // Error: Invalid parameters&#10;    }&#10;    &#10;    /* Wait until bus is free */&#10;    if (i2c_wait_flag(I2Cx, I2C_FLAG_BUSY, 0, I2C_TIMEOUT_BUSY_FLAG) != 0) {&#10;        return 1; // Error: Bus is busy&#10;    }&#10;    &#10;    /* Generate START condition */&#10;    if (i2c_generate_start(I2Cx) != 0) {&#10;        return 1; // Error generating START&#10;    }&#10;    &#10;    /* Send slave address (for write) */&#10;    if (i2c_send_address(I2Cx, DevAddress, I2C_DIRECTION_TRANSMIT) != 0) {&#10;        i2c_generate_stop(I2Cx);&#10;        return 1; // Error sending address&#10;    }&#10;    &#10;    /* Send memory address */&#10;    if (MemAddSize == I2C_MEMADD_SIZE_8BIT) {&#10;        /* Send 8-bit memory address */&#10;        I2Cx-&gt;DR = (uint8_t)(MemAddress &amp; 0xFF);&#10;        &#10;        /* Wait until TXE flag is set */&#10;        if (i2c_wait_flag(I2Cx, I2C_FLAG_TXE, 1, Timeout) != 0) {&#10;            i2c_generate_stop(I2Cx);&#10;            return 1; // Error: TXE timeout&#10;        }&#10;    }&#10;    else { // I2C_MEMADD_SIZE_16BIT&#10;        /* Send MSB of 16-bit memory address */&#10;        I2Cx-&gt;DR = (uint8_t)((MemAddress &gt;&gt; 8) &amp; 0xFF);&#10;        &#10;        /* Wait until TXE flag is set */&#10;        if (i2c_wait_flag(I2Cx, I2C_FLAG_TXE, 1, Timeout) != 0) {&#10;            i2c_generate_stop(I2Cx);&#10;            return 1; // Error: TXE timeout&#10;        }&#10;        &#10;        /* Send LSB of 16-bit memory address */&#10;        I2Cx-&gt;DR = (uint8_t)(MemAddress &amp; 0xFF);&#10;        &#10;        /* Wait until TXE flag is set */&#10;        if (i2c_wait_flag(I2Cx, I2C_FLAG_TXE, 1, Timeout) != 0) {&#10;            i2c_generate_stop(I2Cx);&#10;            return 1; // Error: TXE timeout&#10;        }&#10;    }&#10;    &#10;    /* Generate repeated START condition */&#10;    if (i2c_generate_start(I2Cx) != 0) {&#10;        return 1; // Error generating START&#10;    }&#10;    &#10;    /* Send slave address (for read) */&#10;    if (i2c_send_address(I2Cx, DevAddress, I2C_DIRECTION_RECEIVE) != 0) {&#10;        i2c_generate_stop(I2Cx);&#10;        return 1; // Error sending address&#10;    }&#10;    &#10;    /* Read data - same logic as in master_receive */&#10;    if (Size == 1) {&#10;        /* Disable Acknowledge */&#10;        I2Cx-&gt;CR1 &amp;= ~I2C_CR1_ACK;&#10;        &#10;        /* Clear ADDR flag */&#10;        __IO uint32_t tmp = I2Cx-&gt;SR1;&#10;        tmp = I2Cx-&gt;SR2;&#10;        (void)tmp;&#10;        &#10;        /* Generate STOP condition */&#10;        i2c_generate_stop(I2Cx);&#10;        &#10;        /* Wait until RXNE flag is set */&#10;        if (i2c_wait_flag(I2Cx, I2C_FLAG_RXNE, 1, Timeout) != 0) {&#10;            return 1; // Error: RXNE timeout&#10;        }&#10;        &#10;        /* Read data from DR */&#10;        *pData = (uint8_t)I2Cx-&gt;DR;&#10;    }&#10;    else if (Size == 2) {&#10;        /* Enable POS */&#10;        I2Cx-&gt;CR1 |= I2C_CR1_POS;&#10;        &#10;        /* Clear ADDR flag */&#10;        __IO uint32_t tmp = I2Cx-&gt;SR1;&#10;        tmp = I2Cx-&gt;SR2;&#10;        (void)tmp;&#10;        &#10;        /* Disable Acknowledge */&#10;        I2Cx-&gt;CR1 &amp;= ~I2C_CR1_ACK;&#10;        &#10;        /* Wait until BTF flag is set */&#10;        if (i2c_wait_flag(I2Cx, I2C_FLAG_BTF, 1, Timeout) != 0) {&#10;            return 1; // Error: BTF timeout&#10;        }&#10;        &#10;        /* Generate STOP condition */&#10;        i2c_generate_stop(I2Cx);&#10;        &#10;        /* Read data from DR */&#10;        *pData = (uint8_t)I2Cx-&gt;DR;&#10;        pData++;&#10;        *pData = (uint8_t)I2Cx-&gt;DR;&#10;    }&#10;    else {&#10;        /* Enable Acknowledge */&#10;        I2Cx-&gt;CR1 |= I2C_CR1_ACK;&#10;        &#10;        /* Clear ADDR flag */&#10;        __IO uint32_t tmp = I2Cx-&gt;SR1;&#10;        tmp = I2Cx-&gt;SR2;&#10;        (void)tmp;&#10;        &#10;        while (Size &gt; 3) {&#10;            /* Wait until RXNE flag is set */&#10;            if (i2c_wait_flag(I2Cx, I2C_FLAG_RXNE, 1, Timeout) != 0) {&#10;                i2c_generate_stop(I2Cx);&#10;                return 1; // Error: RXNE timeout&#10;            }&#10;            &#10;            /* Read data from DR */&#10;            *pData = (uint8_t)I2Cx-&gt;DR;&#10;            pData++;&#10;            Size--;&#10;        }&#10;        &#10;        /* When remaining bytes = 3 */&#10;        /* Wait until BTF flag is set */&#10;        if (i2c_wait_flag(I2Cx, I2C_FLAG_BTF, 1, Timeout) != 0) {&#10;            i2c_generate_stop(I2Cx);&#10;            return 1; // Error: BTF timeout&#10;        }&#10;        &#10;        /* Disable Acknowledge */&#10;        I2Cx-&gt;CR1 &amp;= ~I2C_CR1_ACK;&#10;        &#10;        /* Read data N-2 */&#10;        *pData = (uint8_t)I2Cx-&gt;DR;&#10;        pData++;&#10;        &#10;        /* Wait until BTF flag is set */&#10;        if (i2c_wait_flag(I2Cx, I2C_FLAG_BTF, 1, Timeout) != 0) {&#10;            i2c_generate_stop(I2Cx);&#10;            return 1; // Error: BTF timeout&#10;        }&#10;        &#10;        /* Generate STOP condition */&#10;        i2c_generate_stop(I2Cx);&#10;        &#10;        /* Read data N-1 */&#10;        *pData = (uint8_t)I2Cx-&gt;DR;&#10;        pData++;&#10;        &#10;        /* Read data N */&#10;        *pData = (uint8_t)I2Cx-&gt;DR;&#10;    }&#10;    &#10;    /* Reset POS bit */&#10;    I2Cx-&gt;CR1 &amp;= ~I2C_CR1_POS;&#10;    &#10;    /* Enable Acknowledge */&#10;    I2Cx-&gt;CR1 |= I2C_CR1_ACK;&#10;    &#10;    return 0; // Success&#10;}&#10;&#10;/**&#10; * @brief Check if a device is ready to communicate&#10; * &#10; * @details Sends device address and checks for ACK, useful for polling device status&#10; * &#10; * @param I2Cx I2C instance (I2C1, I2C2, or I2C3)&#10; * @param DevAddress Target device address&#10; * @param Trials Number of trials&#10; * @param Timeout Timeout value&#10; * @return uint8_t 0 if device is ready, 1 if not ready&#10; */&#10;uint8_t i2c_is_device_ready(I2C_TypeDef *I2Cx, uint16_t DevAddress, uint8_t Trials, uint32_t Timeout) {&#10;    uint32_t tickstart = 0;&#10;    &#10;    /* Get current tick */&#10;    tickstart = 0; // Replace with actual tick counter&#10;    &#10;    while (Trials &gt; 0) {&#10;        /* Check if the bus is free */&#10;        if (i2c_wait_flag(I2Cx, I2C_FLAG_BUSY, 0, I2C_TIMEOUT_BUSY_FLAG) != 0) {&#10;            return 1; // Error: Bus is busy&#10;        }&#10;        &#10;        /* Generate START condition */&#10;        I2Cx-&gt;CR1 |= I2C_CR1_START;&#10;        &#10;        /* Wait until SB flag is set */&#10;        if (i2c_wait_flag(I2Cx, I2C_FLAG_SB, 1, Timeout) != 0) {&#10;            i2c_generate_stop(I2Cx);&#10;            return 1; // Error generating START&#10;        }&#10;        &#10;        /* Send slave address */&#10;        I2Cx-&gt;DR = (uint8_t)((DevAddress &lt;&lt; 1) | I2C_DIRECTION_TRANSMIT);&#10;        &#10;        /* Wait until ADDR or AF flag is set */&#10;        while ((I2Cx-&gt;SR1 &amp; (I2C_FLAG_ADDR | 0x400)) == 0) {&#10;            /* Check for timeout */&#10;            if ((0 - tickstart) &gt; Timeout) { // Replace with actual tick calculation&#10;                i2c_generate_stop(I2Cx);&#10;                return 1; // Timeout&#10;            }&#10;        }&#10;        &#10;        /* Check if ADDR flag is set (ACK received) */&#10;        if ((I2Cx-&gt;SR1 &amp; I2C_FLAG_ADDR) != 0) {&#10;            /* Clear ADDR flag */&#10;            __IO uint32_t tmp = I2Cx-&gt;SR1;&#10;            tmp = I2Cx-&gt;SR2;&#10;            (void)tmp;&#10;            &#10;            /* Generate STOP condition */&#10;            i2c_generate_stop(I2Cx);&#10;            &#10;            return 0; // Device is ready&#10;        }&#10;        else {&#10;            /* Clear AF flag */&#10;            I2Cx-&gt;SR1 &amp;= ~0x400;&#10;        }&#10;        &#10;        /* Generate STOP condition */&#10;        i2c_generate_stop(I2Cx);&#10;        &#10;        /* Decrement trials */&#10;        Trials--;&#10;        &#10;        /* Wait for a while */&#10;        for (uint32_t i = 0; i &lt; 10000; i++) {&#10;            __NOP();&#10;        }&#10;    }&#10;    &#10;    return 1; // Device is not ready&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Src/systick.c">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Src/systick.c" />
              <option name="originalContent" value="/**&#10; * @file systick_functions.c&#10; * @author Haoyi Chen&#10; * @date 2025-08-10&#10; * @brief SysTick timer implementation&#10; */&#10;&#10;#include &quot;systick.h&quot;&#10;#include &quot;gpio.h&quot;&#10;&#10;/* Global variables */&#10;volatile uint32_t system_tick_ms = 0;&#10;volatile uint32_t system_tick_us = 0;&#10;static volatile uint32_t watchdog_counter = 0;&#10;&#10;/**&#10; * @brief Initialize SysTick timer for 1ms interrupts&#10; */&#10;uint8_t systick_init_ms(uint32_t system_clock_hz)&#10;{&#10;    /* Configure SysTick to generate interrupt every 1ms */&#10;    uint32_t reload_value = system_clock_hz / SYSTICK_FREQUENCY_HZ;&#10;    &#10;    if (reload_value &gt; SysTick_LOAD_RELOAD_Msk) {&#10;        return 1; // Error: reload value too large&#10;    }&#10;    &#10;    /* Configure SysTick */&#10;    SysTick-&gt;LOAD = reload_value - 1;           /* Set reload value */&#10;    SysTick-&gt;VAL = 0;                           /* Clear current value */&#10;    SysTick-&gt;CTRL = SysTick_CTRL_CLKSOURCE_Msk | /* Use processor clock */&#10;                    SysTick_CTRL_TICKINT_Msk |   /* Enable interrupt */&#10;                    SysTick_CTRL_ENABLE_Msk;     /* Enable SysTick */&#10;    &#10;    return 0; // Success&#10;}&#10;&#10;/**&#10; * @brief Initialize SysTick timer for microsecond precision&#10; */&#10;uint8_t systick_init_us(uint32_t system_clock_hz, uint32_t interval_us)&#10;{&#10;    uint32_t reload_value = (system_clock_hz / 1000000) * interval_us;&#10;    &#10;    if (reload_value &gt; SysTick_LOAD_RELOAD_Msk) {&#10;        return 1; // Error: reload value too large&#10;    }&#10;    &#10;    SysTick-&gt;LOAD = reload_value - 1;&#10;    SysTick-&gt;VAL = 0;&#10;    SysTick-&gt;CTRL = SysTick_CTRL_CLKSOURCE_Msk |&#10;                    SysTick_CTRL_TICKINT_Msk |&#10;                    SysTick_CTRL_ENABLE_Msk;&#10;    &#10;    return 0; // Success&#10;}&#10;&#10;/**&#10; * @brief Enable SysTick timer&#10; */&#10;void systick_enable(void)&#10;{&#10;    SysTick-&gt;CTRL |= SysTick_CTRL_ENABLE_Msk;&#10;}&#10;&#10;/**&#10; * @brief Disable SysTick timer&#10; */&#10;void systick_disable(void)&#10;{&#10;    SysTick-&gt;CTRL &amp;= ~SysTick_CTRL_ENABLE_Msk;&#10;}&#10;&#10;/**&#10; * @brief SysTick interrupt handler&#10; */&#10;void systick_irq_handler(void)&#10;{&#10;    system_tick_ms++;&#10;    system_tick_us += 1000; // Assuming 1ms interrupt&#10;    watchdog_counter++;&#10;}&#10;&#10;/**&#10; * @brief Get current system time in milliseconds&#10; */&#10;uint32_t systick_get_ms(void)&#10;{&#10;    return system_tick_ms;&#10;}&#10;&#10;/**&#10; * @brief Get current system time in microseconds&#10; */&#10;uint32_t systick_get_us(void)&#10;{&#10;    return system_tick_us;&#10;}&#10;&#10;/**&#10; * @brief Get elapsed time since a reference point in milliseconds&#10; */&#10;uint32_t systick_elapsed_ms(uint32_t start_time_ms)&#10;{&#10;    uint32_t current_time = systick_get_ms();&#10;    &#10;    /* Handle counter overflow */&#10;    if (current_time &gt;= start_time_ms) {&#10;        return current_time - start_time_ms;&#10;    } else {&#10;        return (0xFFFFFFFF - start_time_ms) + current_time + 1;&#10;    }&#10;}&#10;&#10;/**&#10; * @brief Get elapsed time since a reference point in microseconds&#10; */&#10;uint32_t systick_elapsed_us(uint32_t start_time_us)&#10;{&#10;    uint32_t current_time = systick_get_us();&#10;    &#10;    if (current_time &gt;= start_time_us) {&#10;        return current_time - start_time_us;&#10;    } else {&#10;        return (0xFFFFFFFF - start_time_us) + current_time + 1;&#10;    }&#10;}&#10;&#10;/**&#10; * @brief Blocking delay in milliseconds&#10; */&#10;void systick_delay_ms(uint32_t delay_ms)&#10;{&#10;    uint32_t start_time = systick_get_ms();&#10;    while (systick_elapsed_ms(start_time) &lt; delay_ms) {&#10;        __NOP(); /* Wait */&#10;    }&#10;}&#10;&#10;/**&#10; * @brief Blocking delay in microseconds&#10; */&#10;void systick_delay_us(uint32_t delay_us)&#10;{&#10;    uint32_t start_time = systick_get_us();&#10;    while (systick_elapsed_us(start_time) &lt; delay_us) {&#10;        __NOP(); /* Wait */&#10;    }&#10;}&#10;&#10;/**&#10; * @brief Non-blocking delay check&#10; */&#10;uint8_t systick_delay_elapsed(uint32_t start_time_ms, uint32_t delay_ms)&#10;{&#10;    return (systick_elapsed_ms(start_time_ms) &gt;= delay_ms) ? 1 : 0;&#10;}&#10;&#10;/**&#10; * @brief Initialize a software timer&#10; */&#10;void systick_timer_init(SysTick_Timer_t *timer, uint32_t interval_ms, uint8_t auto_reload)&#10;{&#10;    if (!timer) return;&#10;    &#10;    timer-&gt;start_time = 0;&#10;    timer-&gt;interval = interval_ms;&#10;    timer-&gt;enabled = 0;&#10;    timer-&gt;auto_reload = auto_reload;&#10;}&#10;&#10;/**&#10; * @brief Start a software timer&#10; */&#10;void systick_timer_start(SysTick_Timer_t *timer)&#10;{&#10;    if (!timer) return;&#10;    &#10;    timer-&gt;start_time = systick_get_ms();&#10;    timer-&gt;enabled = 1;&#10;}&#10;&#10;/**&#10; * @brief Stop a software timer&#10; */&#10;void systick_timer_stop(SysTick_Timer_t *timer)&#10;{&#10;    if (!timer) return;&#10;    &#10;    timer-&gt;enabled = 0;&#10;}&#10;&#10;/**&#10; * @brief Check if software timer has expired&#10; */&#10;uint8_t systick_timer_expired(SysTick_Timer_t *timer)&#10;{&#10;    if (!timer || !timer-&gt;enabled) return 0;&#10;    &#10;    if (systick_elapsed_ms(timer-&gt;start_time) &gt;= timer-&gt;interval) {&#10;        if (timer-&gt;auto_reload) {&#10;            timer-&gt;start_time = systick_get_ms(); /* Restart timer */&#10;        } else {&#10;            timer-&gt;enabled = 0; /* One-shot timer */&#10;        }&#10;        return 1; /* Timer expired */&#10;    }&#10;    &#10;    return 0; /* Timer not expired */&#10;}&#10;&#10;/**&#10; * @brief Reset software timer&#10; */&#10;void systick_timer_reset(SysTick_Timer_t *timer)&#10;{&#10;    if (!timer) return;&#10;    &#10;    timer-&gt;start_time = systick_get_ms();&#10;}&#10;&#10;/**&#10; * @brief Start performance measurement&#10; */&#10;uint32_t systick_perf_start(void)&#10;{&#10;    return systick_get_us();&#10;}&#10;&#10;/**&#10; * @brief End performance measurement and get elapsed time&#10; */&#10;uint32_t systick_perf_end(uint32_t start_time)&#10;{&#10;    return systick_elapsed_us(start_time);&#10;}&#10;&#10;/**&#10; * @brief Simple heartbeat LED toggle&#10; */&#10;void systick_heartbeat(GPIO_TypeDef *led_port, uint8_t led_pin, uint32_t interval_ms)&#10;{&#10;    static uint32_t last_toggle = 0;&#10;    &#10;    if (systick_elapsed_ms(last_toggle) &gt;= interval_ms) {&#10;        gpio_toggle(led_port, led_pin);&#10;        last_toggle = systick_get_ms();&#10;    }&#10;}&#10;&#10;/**&#10; * @brief Software watchdog timer&#10; */&#10;uint8_t systick_watchdog_check(uint32_t timeout_ms)&#10;{&#10;    return (watchdog_counter * 1) &gt;= timeout_ms ? 1 : 0; /* Assuming 1ms SysTick */&#10;}&#10;&#10;/**&#10; * @brief Reset software watchdog timer&#10; */&#10;void systick_watchdog_reset(void)&#10;{&#10;    watchdog_counter = 0;&#10;}&#10;&#10;/**&#10; * @brief Convert milliseconds to system ticks&#10; */&#10;uint32_t systick_ms_to_ticks(uint32_t ms)&#10;{&#10;    return ms * (SYSTICK_FREQUENCY_HZ / 1000);&#10;}&#10;&#10;/**&#10; * @brief Convert system ticks to milliseconds&#10; */&#10;uint32_t systick_ticks_to_ms(uint32_t ticks)&#10;{&#10;    return ticks / (SYSTICK_FREQUENCY_HZ / 1000);&#10;}&#10;&#10;/**&#10; * @brief Get system uptime in seconds&#10; */&#10;uint32_t systick_get_uptime_seconds(void)&#10;{&#10;    return systick_get_ms() / 1000;&#10;}&#10;&#10;/**&#10; * @brief Convert uptime to hours:minutes:seconds format&#10; */&#10;void systick_get_uptime_hms(uint32_t *hours, uint32_t *minutes, uint32_t *seconds)&#10;{&#10;    uint32_t total_seconds = systick_get_uptime_seconds();&#10;    &#10;    *hours = total_seconds / 3600;&#10;    *minutes = (total_seconds % 3600) / 60;&#10;    *seconds = total_seconds % 60;&#10;}&#10;&#10;/**&#10; * @brief Initialize task scheduler&#10; */&#10;void systick_task_init(SysTick_Task_t *task, void (*function)(void), uint32_t interval_ms)&#10;{&#10;    if (!task || !function) return;&#10;    &#10;    task-&gt;task_function = function;&#10;    task-&gt;interval_ms = interval_ms;&#10;    task-&gt;last_execution = systick_get_ms();&#10;    task-&gt;enabled = 1;&#10;}&#10;&#10;/**&#10; * @brief Run task scheduler&#10; */&#10;void systick_task_run(SysTick_Task_t *task)&#10;{&#10;    if (!task || !task-&gt;enabled || !task-&gt;task_function) return;&#10;    &#10;    uint32_t current_time = systick_get_ms();&#10;    &#10;    if (systick_elapsed_ms(task-&gt;last_execution) &gt;= task-&gt;interval_ms) {&#10;        task-&gt;task_function(); /* Execute task */&#10;        task-&gt;last_execution = current_time;&#10;    }&#10;}&#10;&#10;/**&#10; * @brief Enable/disable task&#10; */&#10;void systick_task_enable(SysTick_Task_t *task, uint8_t enabled)&#10;{&#10;    if (!task) return;&#10;    &#10;    task-&gt;enabled = enabled;&#10;    if (enabled) {&#10;        task-&gt;last_execution = systick_get_ms(); /* Reset timing */&#10;    }&#10;}" />
              <option name="updatedContent" value="/**&#10; ******************************************************************************&#10; * @file           : systick.c&#10; * @author         : Haoyi Chen&#10; * @date           : 2025-08-10&#10; * @brief          : SysTick timer implementation for timing operations&#10; ******************************************************************************&#10; * @details&#10; * This file implements essential SysTick timer functions for embedded systems.&#10; * Provides system time keeping, delays, and simple software timers using the&#10; * ARM Cortex-M SysTick timer peripheral configured for 1ms interrupts.&#10; *&#10; * Key features:&#10; * - 1ms system tick resolution&#10; * - Overflow-safe time calculations&#10; * - Blocking and non-blocking delay functions&#10; * - Lightweight software timer implementation&#10; ******************************************************************************&#10; */&#10;&#10;#include &quot;systick.h&quot;&#10;&#10;/* Global variables */&#10;volatile uint32_t system_tick_ms = 0;    /**&lt; System time counter in milliseconds */&#10;&#10;/**&#10; * @brief Initialize SysTick timer for 1ms interrupts&#10; * &#10; * @details Configures the ARM Cortex-M SysTick timer to generate interrupts&#10; *          every 1ms using the processor clock. The SysTick timer is a 24-bit&#10; *          down-counter that reloads from a specified value.&#10; * &#10; * @param system_clock_hz System clock frequency in Hz (typically 168MHz for STM32F407)&#10; * @return uint8_t 0 if successful, 1 if reload value exceeds 24-bit limit&#10; * &#10; * @note SysTick uses processor clock (HCLK) as clock source&#10; * @warning Maximum reload value is 0xFFFFFF (24-bit), limiting max clock to ~16.7MHz&#10; */&#10;uint8_t systick_init(uint32_t system_clock_hz)&#10;{&#10;    /* Calculate reload value for 1ms interrupts: clock_hz / 1000Hz */&#10;    uint32_t reload_value = system_clock_hz / SYSTICK_FREQUENCY_HZ;&#10;    &#10;    /* Check if reload value fits in 24-bit register */&#10;    if (reload_value &gt; SysTick_LOAD_RELOAD_Msk) {&#10;        return 1; // Error: reload value too large for 24-bit register&#10;    }&#10;    &#10;    /* Configure SysTick timer */&#10;    SysTick-&gt;LOAD = reload_value - 1;           /* Set reload value (minus 1 for 0-based counting) */&#10;    SysTick-&gt;VAL = 0;                           /* Clear current value register */&#10;    SysTick-&gt;CTRL = SysTick_CTRL_CLKSOURCE_Msk | /* Use processor clock (HCLK) */&#10;                    SysTick_CTRL_TICKINT_Msk |   /* Enable SysTick interrupt */&#10;                    SysTick_CTRL_ENABLE_Msk;     /* Enable SysTick timer */&#10;    &#10;    return 0; // Success&#10;}&#10;&#10;/**&#10; * @brief SysTick interrupt handler&#10; * &#10; * @details This function must be called from the SysTick_Handler() interrupt&#10; *          service routine. It increments the global millisecond counter that&#10; *          serves as the system timebase.&#10; * &#10; * @note Called automatically every 1ms when SysTick interrupt occurs&#10; * @note Keep this function lightweight to minimize interrupt latency&#10; */&#10;void systick_irq_handler(void)&#10;{&#10;    system_tick_ms++;    /* Increment millisecond counter */&#10;}&#10;&#10;/**&#10; * @brief Get current system time in milliseconds&#10; * &#10; * @details Returns the current system time since initialization. The counter&#10; *          will overflow after approximately 49.7 days (2^32 ms = 4,294,967,296 ms).&#10; * &#10; * @return uint32_t Current system time in milliseconds&#10; * &#10; * @note Thread-safe: atomic read of volatile variable&#10; * @note Can be called from interrupt context&#10; */&#10;uint32_t systick_get_ms(void)&#10;{&#10;    return system_tick_ms;&#10;}&#10;&#10;/**&#10; * @brief Calculate elapsed time since a reference point&#10; * &#10; * @details Calculates time difference between current time and a reference time,&#10; *          correctly handling 32-bit counter overflow. This allows measuring&#10; *          intervals even when the counter rolls over.&#10; * &#10; * @param start_time_ms Reference time obtained from systick_get_ms()&#10; * @return uint32_t Elapsed time in milliseconds&#10; * &#10; * @note Handles counter overflow: works correctly across 32-bit boundary&#10; * @note Maximum measurable interval is ~49 days (full 32-bit range)&#10; */&#10;uint32_t systick_elapsed_ms(uint32_t start_time_ms)&#10;{&#10;    uint32_t current_time = systick_get_ms();&#10;    &#10;    /* Handle counter overflow using unsigned arithmetic properties */&#10;    if (current_time &gt;= start_time_ms) {&#10;        return current_time - start_time_ms;    /* Normal case: no overflow */&#10;    } else {&#10;        /* Overflow case: calculate elapsed time across 32-bit boundary */&#10;        return (0xFFFFFFFF - start_time_ms) + current_time + 1;&#10;    }&#10;}&#10;&#10;/**&#10; * @brief Blocking delay in milliseconds&#10; * &#10; * @details Blocks program execution for the specified time period using&#10; *          active polling. Other interrupts can still execute during delay.&#10; * &#10; * @param delay_ms Delay duration in milliseconds&#10; * &#10; * @warning Blocking function: CPU is occupied during delay&#10; * @note Use systick_delay_elapsed() for non-blocking timing in main loops&#10; * @note Actual delay may be up to 1ms longer due to timing granularity&#10; */&#10;void systick_delay_ms(uint32_t delay_ms)&#10;{&#10;    uint32_t start_time = systick_get_ms();    /* Record start time */&#10;    &#10;    /* Poll until desired time has elapsed */&#10;    while (systick_elapsed_ms(start_time) &lt; delay_ms) {&#10;        __NOP();    /* No operation: prevents compiler optimization */&#10;    }&#10;}&#10;&#10;/**&#10; * @brief Check if a delay period has elapsed (non-blocking)&#10; * &#10; * @details Non-blocking function to check if a specified time period has&#10; *          passed since a reference time. Ideal for main loop timing without&#10; *          blocking execution.&#10; * &#10; * @param start_time_ms Reference time from systick_get_ms()&#10; * @param delay_ms Desired delay period in milliseconds&#10; * @return uint8_t 1 if delay period has elapsed, 0 if still waiting&#10; * &#10; * @note Preferred method for timing in event-driven applications&#10; * @note Does not block execution: allows other tasks to run&#10; * &#10; * @code&#10; * // Example usage in main loop:&#10; * uint32_t last_time = systick_get_ms();&#10; * while(1) {&#10; *     if (systick_delay_elapsed(last_time, 1000)) {&#10; *         // Execute every 1000ms&#10; *         last_time = systick_get_ms();&#10; *     }&#10; *     // Other tasks can run here&#10; * }&#10; * @endcode&#10; */&#10;uint8_t systick_delay_elapsed(uint32_t start_time_ms, uint32_t delay_ms)&#10;{&#10;    return (systick_elapsed_ms(start_time_ms) &gt;= delay_ms) ? 1 : 0;&#10;}&#10;&#10;/**&#10; * @brief Initialize a software timer&#10; * &#10; * @details Sets up a software timer structure with specified interval and mode.&#10; *          The timer is created in stopped state and must be started explicitly.&#10; * &#10; * @param timer Pointer to timer structure to initialize&#10; * @param interval_ms Timer period in milliseconds&#10; * @param auto_reload 1 for continuous timer, 0 for one-shot timer&#10; * &#10; * @note Timer is initialized in stopped state&#10; * @note Use systick_timer_start() to begin timing&#10; * &#10; * @code&#10; * // Example: Create a 500ms auto-reload timer&#10; * SysTick_Timer_t led_timer;&#10; * systick_timer_init(&amp;led_timer, 500, 1);&#10; * systick_timer_start(&amp;led_timer);&#10; * @endcode&#10; */&#10;void systick_timer_init(SysTick_Timer_t *timer, uint32_t interval_ms, uint8_t auto_reload)&#10;{&#10;    if (!timer) return;    /* Null pointer protection */&#10;    &#10;    timer-&gt;start_time = 0;          /* Initialize start time */&#10;    timer-&gt;interval = interval_ms;   /* Set timer interval */&#10;    timer-&gt;enabled = 0;             /* Timer starts disabled */&#10;    timer-&gt;auto_reload = auto_reload; /* Set reload mode */&#10;}&#10;&#10;/**&#10; * @brief Start a software timer&#10; * &#10; * @details Starts timer counting from the current system time. Can be used&#10; *          to start a new timer or restart an expired timer.&#10; * &#10; * @param timer Pointer to initialized timer structure&#10; * &#10; * @note Timer begins counting immediately from current system time&#10; * @note Can be called multiple times to restart timer&#10; */&#10;void systick_timer_start(SysTick_Timer_t *timer)&#10;{&#10;    if (!timer) return;    /* Null pointer protection */&#10;    &#10;    timer-&gt;start_time = systick_get_ms();    /* Record current time */&#10;    timer-&gt;enabled = 1;                      /* Enable timer */&#10;}&#10;&#10;/**&#10; * @brief Check if software timer has expired&#10; * &#10; * @details Checks if the timer interval has elapsed. For auto-reload timers,&#10; *          automatically restarts the timer when expired. For one-shot timers,&#10; *          disables the timer when expired.&#10; * &#10; * @param timer Pointer to timer structure&#10; * @return uint8_t 1 if timer expired, 0 if still counting&#10; * &#10; * @note Call this function periodically (e.g., in main loop)&#10; * @note Auto-reload timers restart automatically&#10; * @note One-shot timers stop automatically after expiring&#10; * &#10; * @code&#10; * // Example usage in main loop:&#10; * while(1) {&#10; *     if (systick_timer_expired(&amp;led_timer)) {&#10; *         // Execute every timer interval&#10; *         toggle_led();&#10; *     }&#10; *     // Other tasks...&#10; * }&#10; * @endcode&#10; */&#10;uint8_t systick_timer_expired(SysTick_Timer_t *timer)&#10;{&#10;    if (!timer || !timer-&gt;enabled) return 0;    /* Check valid and enabled timer */&#10;    &#10;    /* Check if timer interval has elapsed */&#10;    if (systick_elapsed_ms(timer-&gt;start_time) &gt;= timer-&gt;interval) {&#10;        if (timer-&gt;auto_reload) {&#10;            /* Auto-reload timer: restart automatically */&#10;            timer-&gt;start_time = systick_get_ms();&#10;        } else {&#10;            /* One-shot timer: disable after expiring */&#10;            timer-&gt;enabled = 0;&#10;        }&#10;        return 1;    /* Timer expired */&#10;    }&#10;    &#10;    return 0;    /* Timer still counting */&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>