<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/Inc/i2c.h">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Inc/i2c.h" />
              <option name="updatedContent" value="// filepath: /Users/haoyi/Documents/Code/Electronics_for_embedded_systems/Motor_monitor/Software/Inc/i2c.h&#10;/**&#10; * @file i2c.h&#10; * @author Haoyi Chen&#10; * @date 2025-08-08&#10; * @brief STM32F4 I2C register-level driver header&#10; *&#10; * @details This file contains I2C function declarations, structures, and macro definitions&#10; * for STM32F407 series microcontrollers.&#10; */&#10;&#10;#ifndef I2C_H&#10;#define I2C_H&#10;&#10;#include &quot;stm32f407xx.h&quot;&#10;&#10;/**&#10; * @brief I2C initialization configuration structure&#10; */&#10;typedef struct {&#10;    uint32_t ClockSpeed;       /**&lt; I2C clock frequency in Hz */&#10;    uint8_t OwnAddress1;       /**&lt; First device own address */&#10;    uint8_t AddressingMode;    /**&lt; I2C addressing mode (7 or 10 bit) */&#10;    uint8_t DualAddressMode;   /**&lt; Dual addressing mode enable/disable */&#10;    uint8_t OwnAddress2;       /**&lt; Second device own address (if dual mode enabled) */&#10;    uint8_t GeneralCallMode;   /**&lt; General call mode enable/disable */&#10;    uint8_t NoStretchMode;     /**&lt; Clock stretching disable/enable */&#10;    uint8_t DutyCycle;         /**&lt; Fast mode duty cycle */&#10;} I2C_InitTypeDef;&#10;&#10;/**&#10; * @name I2C Addressing Mode&#10; * @{&#10; */&#10;#define I2C_ADDRESSINGMODE_7BIT    0x00000000U  /**&lt; 7-bit addressing mode */&#10;#define I2C_ADDRESSINGMODE_10BIT   0x00000080U  /**&lt; 10-bit addressing mode */&#10;/** @} */&#10;&#10;/**&#10; * @name I2C Dual Addressing Mode&#10; * @{&#10; */&#10;#define I2C_DUALADDRESS_DISABLE    0x00000000U  /**&lt; Dual addressing mode disabled */&#10;#define I2C_DUALADDRESS_ENABLE     0x00000001U  /**&lt; Dual addressing mode enabled */&#10;/** @} */&#10;&#10;/**&#10; * @name I2C General Call Mode&#10; * @{&#10; */&#10;#define I2C_GENERALCALL_DISABLE    0x00000000U  /**&lt; General call mode disabled */&#10;#define I2C_GENERALCALL_ENABLE     0x00000040U  /**&lt; General call mode enabled */&#10;/** @} */&#10;&#10;/**&#10; * @name I2C No Stretch Mode&#10; * @{&#10; */&#10;#define I2C_NOSTRETCH_DISABLE      0x00000000U  /**&lt; Clock stretching enabled */&#10;#define I2C_NOSTRETCH_ENABLE       0x00000080U  /**&lt; Clock stretching disabled */&#10;/** @} */&#10;&#10;/**&#10; * @name I2C Fast Mode Duty Cycle&#10; * @{&#10; */&#10;#define I2C_DUTYCYCLE_2            0x00000000U  /**&lt; Fast mode duty cycle tlow/thigh = 2 */&#10;#define I2C_DUTYCYCLE_16_9         0x00004000U  /**&lt; Fast mode duty cycle tlow/thigh = 16/9 */&#10;/** @} */&#10;&#10;/**&#10; * @name I2C Direction (for transfer functions)&#10; * @{&#10; */&#10;#define I2C_DIRECTION_TRANSMIT     0x00        /**&lt; I2C master transmitter direction */&#10;#define I2C_DIRECTION_RECEIVE      0x01        /**&lt; I2C master receiver direction */&#10;/** @} */&#10;&#10;/**&#10; * @name I2C Memory Address Size&#10; * @{&#10; */&#10;#define I2C_MEMADD_SIZE_8BIT       0x01        /**&lt; 8-bit memory address size */&#10;#define I2C_MEMADD_SIZE_16BIT      0x02        /**&lt; 16-bit memory address size */&#10;/** @} */&#10;&#10;/**&#10; * @name I2C Timeout values&#10; * @{&#10; */&#10;#define I2C_TIMEOUT_FLAG           10000       /**&lt; Timeout value for flag waiting */&#10;#define I2C_TIMEOUT_BUSY_FLAG      25000       /**&lt; Timeout value for busy flag waiting */&#10;/** @} */&#10;&#10;/**&#10; * @name I2C Status flags&#10; * @{&#10; */&#10;#define I2C_FLAG_BUSY              0x00020000U   /**&lt; Bus busy flag */&#10;#define I2C_FLAG_MSL               0x00010000U   /**&lt; Master/Slave flag */&#10;#define I2C_FLAG_TXE               0x00000080U   /**&lt; Data register empty flag (transmitter) */&#10;#define I2C_FLAG_RXNE              0x00000040U   /**&lt; Data register not empty flag (receiver) */&#10;#define I2C_FLAG_STOPF             0x00000010U   /**&lt; Stop detection flag */&#10;#define I2C_FLAG_ADD10             0x00000008U   /**&lt; 10-bit header sent flag */&#10;#define I2C_FLAG_BTF               0x00000004U   /**&lt; Byte transfer finished flag */&#10;#define I2C_FLAG_ADDR              0x00000002U   /**&lt; Address sent flag */&#10;#define I2C_FLAG_SB                0x00000001U   /**&lt; Start bit flag */&#10;/** @} */&#10;&#10;/**&#10; * @brief Initialize I2C with the specified parameters&#10; * &#10; * @param I2Cx I2C instance (I2C1, I2C2, or I2C3)&#10; * @param init Pointer to I2C initialization structure&#10; * &#10; * @note I2C clock must be enabled separately via RCC registers before calling this function&#10; */&#10;void i2c_init(I2C_TypeDef *I2Cx, I2C_InitTypeDef *init);&#10;&#10;/**&#10; * @brief Initialize GPIO pins for I2C&#10; * &#10; * @param I2Cx I2C instance (I2C1, I2C2, or I2C3)&#10; * @param GPIOx GPIO port for SCL pin (GPIOA, GPIOB, etc.)&#10; * @param SCL_Pin SCL pin number (0-15)&#10; * @param SDA_Pin SDA pin number (0-15)&#10; * &#10; * @note GPIO clock must be enabled separately via RCC registers&#10; */&#10;void i2c_gpio_init(I2C_TypeDef *I2Cx, GPIO_TypeDef *GPIOx, uint8_t SCL_Pin, uint8_t SDA_Pin);&#10;&#10;/**&#10; * @brief Check if the I2C bus is free&#10; * &#10; * @param I2Cx I2C instance (I2C1, I2C2, or I2C3)&#10; * @return uint8_t 1 if bus is free, 0 if busy&#10; */&#10;uint8_t i2c_is_bus_free(I2C_TypeDef *I2Cx);&#10;&#10;/**&#10; * @brief Wait for a specific I2C flag to be set or reset&#10; * &#10; * @param I2Cx I2C instance (I2C1, I2C2, or I2C3)&#10; * @param flag Flag to check&#10; * @param status Expected status (1 for set, 0 for reset)&#10; * @param timeout Timeout value&#10; * @return uint8_t 0 if successful (flag matched expected state), 1 if timeout&#10; */&#10;uint8_t i2c_wait_flag(I2C_TypeDef *I2Cx, uint32_t flag, uint8_t status, uint32_t timeout);&#10;&#10;/**&#10; * @brief Generate start condition on I2C bus&#10; * &#10; * @param I2Cx I2C instance (I2C1, I2C2, or I2C3)&#10; * @return uint8_t 0 if successful, 1 if error&#10; */&#10;uint8_t i2c_generate_start(I2C_TypeDef *I2Cx);&#10;&#10;/**&#10; * @brief Generate stop condition on I2C bus&#10; * &#10; * @param I2Cx I2C instance (I2C1, I2C2, or I2C3)&#10; * @return uint8_t 0 if successful, 1 if error&#10; */&#10;uint8_t i2c_generate_stop(I2C_TypeDef *I2Cx);&#10;&#10;/**&#10; * @brief Send 7-bit or 10-bit device address&#10; * &#10; * @param I2Cx I2C instance (I2C1, I2C2, or I2C3)&#10; * @param DevAddress Target device address&#10; * @param Direction Direction (I2C_DIRECTION_TRANSMIT or I2C_DIRECTION_RECEIVE)&#10; * @return uint8_t 0 if successful, 1 if error&#10; */&#10;uint8_t i2c_send_address(I2C_TypeDef *I2Cx, uint16_t DevAddress, uint8_t Direction);&#10;&#10;/**&#10; * @brief Master transmit data to a slave device&#10; * &#10; * @param I2Cx I2C instance (I2C1, I2C2, or I2C3)&#10; * @param DevAddress Target device address&#10; * @param pData Pointer to data buffer&#10; * @param Size Amount of data to be sent&#10; * @param Timeout Timeout value&#10; * @return uint8_t 0 if successful, 1 if error&#10; */&#10;uint8_t i2c_master_transmit(I2C_TypeDef *I2Cx, uint16_t DevAddress, uint8_t *pData, uint16_t Size, uint32_t Timeout);&#10;&#10;/**&#10; * @brief Master receive data from a slave device&#10; * &#10; * @param I2Cx I2C instance (I2C1, I2C2, or I2C3)&#10; * @param DevAddress Target device address&#10; * @param pData Pointer to data buffer&#10; * @param Size Amount of data to be received&#10; * @param Timeout Timeout value&#10; * @return uint8_t 0 if successful, 1 if error&#10; */&#10;uint8_t i2c_master_receive(I2C_TypeDef *I2Cx, uint16_t DevAddress, uint8_t *pData, uint16_t Size, uint32_t Timeout);&#10;&#10;/**&#10; * @brief Write to a memory address of an I2C slave device&#10; * &#10; * @param I2Cx I2C instance (I2C1, I2C2, or I2C3)&#10; * @param DevAddress Target device address&#10; * @param MemAddress Internal memory address&#10; * @param MemAddSize Size of memory address (I2C_MEMADD_SIZE_8BIT or I2C_MEMADD_SIZE_16BIT)&#10; * @param pData Pointer to data buffer&#10; * @param Size Amount of data to be sent&#10; * @param Timeout Timeout value&#10; * @return uint8_t 0 if successful, 1 if error&#10; */&#10;uint8_t i2c_mem_write(I2C_TypeDef *I2Cx, uint16_t DevAddress, uint16_t MemAddress, &#10;                      uint8_t MemAddSize, uint8_t *pData, uint16_t Size, uint32_t Timeout);&#10;&#10;/**&#10; * @brief Read from a memory address of an I2C slave device&#10; * &#10; * @param I2Cx I2C instance (I2C1, I2C2, or I2C3)&#10; * @param DevAddress Target device address&#10; * @param MemAddress Internal memory address&#10; * @param MemAddSize Size of memory address (I2C_MEMADD_SIZE_8BIT or I2C_MEMADD_SIZE_16BIT)&#10; * @param pData Pointer to data buffer&#10; * @param Size Amount of data to be read&#10; * @param Timeout Timeout value&#10; * @return uint8_t 0 if successful, 1 if error&#10; */&#10;uint8_t i2c_mem_read(I2C_TypeDef *I2Cx, uint16_t DevAddress, uint16_t MemAddress, &#10;                     uint8_t MemAddSize, uint8_t *pData, uint16_t Size, uint32_t Timeout);&#10;&#10;/**&#10; * @brief Check if a device is ready to communicate&#10; * &#10; * @param I2Cx I2C instance (I2C1, I2C2, or I2C3)&#10; * @param DevAddress Target device address&#10; * @param Trials Number of trials&#10; * @param Timeout Timeout value&#10; * @return uint8_t 0 if device is ready, 1 if not ready&#10; */&#10;uint8_t i2c_is_device_ready(I2C_TypeDef *I2Cx, uint16_t DevAddress, uint8_t Trials, uint32_t Timeout);&#10;&#10;#endif /* I2C_H */" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Inc/system_init.h">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Inc/system_init.h" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Src/dma.c">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Src/dma.c" />
              <option name="originalContent" value="/**&#10; * @file dma.c&#10; * @author Haoyi Chen&#10; * @date 2025-08-08&#10; * @brief STM32F4 DMA register-level driver&#10; *&#10; * @details This file provides basic DMA initialization, configuration and operation&#10; * functions for STM32F407 series microcontrollers. All operations are performed at the &#10; * register level, without using HAL or LL libraries.&#10; *&#10; * Created for personal learning and embedded systems experimentation.&#10; */&#10;&#10;#include &quot;dma.h&quot;&#10;&#10;/**&#10; * @brief Get DMA stream register pointer&#10; * &#10; * @details Helper function to get pointer to the right stream register set&#10; * &#10; * @param DMAx DMA instance (DMA1 or DMA2)&#10; * @param stream Stream number (0-7)&#10; * @return DMA_Stream_TypeDef* Pointer to the DMA stream registers&#10; */&#10;static DMA_Stream_TypeDef* dma_get_stream(DMA_TypeDef *DMAx, uint32_t stream) {&#10;    return (DMA_Stream_TypeDef *)((uint32_t)((uint32_t)DMAx + 0x10 + (0x18 * stream)));&#10;}&#10;&#10;/**&#10; * @brief Initialize DMA stream with the specified parameters&#10; * &#10; * @details Configures DMA stream by setting channel, direction, increment modes,&#10; *          data alignment, mode, priority, and FIFO settings.&#10; *&#10; * @param DMAx DMA instance (DMA1 or DMA2)&#10; * @param stream Stream number (0-7)&#10; * @param init Pointer to DMA initialization structure&#10; * &#10; * @note DMA clock must be enabled separately via RCC registers before calling this function&#10; */&#10;void dma_init(DMA_TypeDef *DMAx, uint32_t stream, DMA_InitTypeDef *init) {&#10;    DMA_Stream_TypeDef *DMAStream = dma_get_stream(DMAx, stream);&#10;    &#10;    /* Disable the DMA Stream first */&#10;    DMAStream-&gt;CR &amp;= ~DMA_SxCR_EN;&#10;    &#10;    /* Wait until the stream is effectively disabled */&#10;    while(DMAStream-&gt;CR &amp; DMA_SxCR_EN);&#10;    &#10;    /* Clear all interrupt flags for the selected stream */&#10;    /* This is critical for proper DMA operation */&#10;    if (DMAx == DMA1) {&#10;        if (stream &lt; 4) {&#10;            /* Streams 0-3 use LIFCR register */&#10;            DMA1-&gt;LIFCR = (0x3F &lt;&lt; (stream * 6)); /* Clear all flags for this stream */&#10;        } else {&#10;            /* Streams 4-7 use HIFCR register */&#10;            DMA1-&gt;HIFCR = (0x3F &lt;&lt; ((stream - 4) * 6)); /* Clear all flags for this stream */&#10;        }&#10;    } else { /* DMA2 */&#10;        if (stream &lt; 4) {&#10;            /* Streams 0-3 use LIFCR register */&#10;            DMA2-&gt;LIFCR = (0x3F &lt;&lt; (stream * 6)); /* Clear all flags for this stream */&#10;        } else {&#10;            /* Streams 4-7 use HIFCR register */&#10;            DMA2-&gt;HIFCR = (0x3F &lt;&lt; ((stream - 4) * 6)); /* Clear all flags for this stream */&#10;        }&#10;    }&#10;    &#10;    /* Configure the source, destination and buffer size */&#10;    DMAStream-&gt;PAR = 0;&#10;    DMAStream-&gt;M0AR = 0;&#10;    DMAStream-&gt;NDTR = 0;&#10;    &#10;    /* Configure CR register - do this in one write operation */&#10;    DMAStream-&gt;CR = init-&gt;Channel | init-&gt;Direction | init-&gt;PeriphInc | init-&gt;MemInc |&#10;                    init-&gt;PeriphDataAlign | init-&gt;MemDataAlign | init-&gt;Mode | init-&gt;Priority;&#10;    &#10;    /* Configure FIFO */&#10;    DMAStream-&gt;FCR = init-&gt;FIFOMode | init-&gt;FIFOThreshold | init-&gt;MemBurst | init-&gt;PeriphBurst;&#10;}&#10;&#10;/**&#10; * @brief Configure DMA transfer parameters&#10; * &#10; * @details Sets up source and destination addresses and transfer count for DMA operation&#10; *&#10; * @param DMAx DMA instance (DMA1 or DMA2)&#10; * @param stream Stream number (0-7)&#10; * @param SrcAddress Source address&#10; * @param DstAddress Destination address&#10; * @param DataLength Number of data items to transfer&#10; * &#10; * @note This function should be called after dma_init&#10; */&#10;void dma_config_transfer(DMA_TypeDef *DMAx, uint32_t stream, uint32_t SrcAddress, uint32_t DstAddress, uint16_t DataLength) {&#10;    DMA_Stream_TypeDef *DMAStream = dma_get_stream(DMAx, stream);&#10;    &#10;    /* Make sure the stream is disabled */&#10;    if (DMAStream-&gt;CR &amp; DMA_SxCR_EN) {&#10;        DMAStream-&gt;CR &amp;= ~DMA_SxCR_EN;&#10;        while(DMAStream-&gt;CR &amp; DMA_SxCR_EN);&#10;    }&#10;    &#10;    /* Clear any pending flags for this stream before configuration */&#10;    if (DMAx == DMA1) {&#10;        if (stream &lt; 4) {&#10;            DMA1-&gt;LIFCR = (0x3F &lt;&lt; (stream * 6)); /* Clear all flags for this stream */&#10;        } else {&#10;            DMA1-&gt;HIFCR = (0x3F &lt;&lt; ((stream - 4) * 6)); /* Clear all flags for this stream */&#10;        }&#10;    } else { /* DMA2 */&#10;        if (stream &lt; 4) {&#10;            DMA2-&gt;LIFCR = (0x3F &lt;&lt; (stream * 6)); /* Clear all flags for this stream */&#10;        } else {&#10;            DMA2-&gt;HIFCR = (0x3F &lt;&lt; ((stream - 4) * 6)); /* Clear all flags for this stream */&#10;        }&#10;    }&#10;    &#10;    /* Configure source, destination and data length according to direction */&#10;    uint32_t direction = DMAStream-&gt;CR &amp; DMA_SxCR_DIR;&#10;    &#10;    if (direction == DMA_PERIPH_TO_MEMORY) {&#10;        /* Peripheral to memory (e.g., ADC to RAM) */&#10;        DMAStream-&gt;PAR = SrcAddress;    /* Peripheral is source (e.g., ADC data register) */&#10;        DMAStream-&gt;M0AR = DstAddress;   /* Memory is destination (e.g., buffer array) */&#10;    } else if (direction == DMA_MEMORY_TO_PERIPH) {&#10;        /* Memory to peripheral (e.g., RAM to DAC) */&#10;        DMAStream-&gt;PAR = DstAddress;    /* Peripheral is destination (e.g., DAC data register) */&#10;        DMAStream-&gt;M0AR = SrcAddress;   /* Memory is source (e.g., buffer array) */&#10;    } else if (direction == DMA_MEMORY_TO_MEMORY) {&#10;        /* Memory to memory */&#10;        DMAStream-&gt;PAR = SrcAddress;    /* Source memory address */&#10;        DMAStream-&gt;M0AR = DstAddress;   /* Destination memory address */&#10;    }&#10;    &#10;    /* Set data length - verify it's within limits first */&#10;    if (DataLength &gt; 0 &amp;&amp; DataLength &lt;= 65535) {&#10;        DMAStream-&gt;NDTR = DataLength;   /* Number of data items to transfer */&#10;    } else {&#10;        /* Handle invalid length - default to a safe value */&#10;        DMAStream-&gt;NDTR = 1;            /* Set to minimum safe value */&#10;    }&#10;}&#10;&#10;/**&#10; * @brief Enable DMA stream&#10; * &#10; * @details Sets the EN bit in the DMA_SxCR register to start DMA transfer&#10; * &#10; * @param DMAx DMA instance (DMA1 or DMA2)&#10; * @param stream Stream number (0-7)&#10; */&#10;void dma_enable(DMA_TypeDef *DMAx, uint32_t stream) {&#10;    DMA_Stream_TypeDef *DMAStream = dma_get_stream(DMAx, stream);&#10;    DMAStream-&gt;CR |= DMA_SxCR_EN;&#10;}&#10;&#10;/**&#10; * @brief Disable DMA stream&#10; * &#10; * @details Clears the EN bit in the DMA_SxCR register to stop DMA transfer&#10; * &#10; * @param DMAx DMA instance (DMA1 or DMA2)&#10; * @param stream Stream number (0-7)&#10; */&#10;void dma_disable(DMA_TypeDef *DMAx, uint32_t stream) {&#10;    DMA_Stream_TypeDef *DMAStream = dma_get_stream(DMAx, stream);&#10;    DMAStream-&gt;CR &amp;= ~DMA_SxCR_EN;&#10;}&#10;&#10;/**&#10; * @brief Enable DMA interrupt&#10; * &#10; * @details Enables specified DMA interrupts by setting corresponding bits in the CR register&#10; * &#10; * @param DMAx DMA instance (DMA1 or DMA2)&#10; * @param stream Stream number (0-7)&#10; * @param interrupt Interrupts to enable (combination of DMA_IT_xx flags)&#10; */&#10;void dma_enable_interrupt(DMA_TypeDef *DMAx, uint32_t stream, uint32_t interrupt) {&#10;    DMA_Stream_TypeDef *DMAStream = dma_get_stream(DMAx, stream);&#10;    &#10;    /* 直接使用系统定义的中断标志宏 */&#10;    if (interrupt &amp; DMA_SxCR_TCIE) {&#10;        DMAStream-&gt;CR |= DMA_SxCR_TCIE;  /* 传输完成中断 */&#10;    }&#10;    if (interrupt &amp; DMA_SxCR_HTIE) {&#10;        DMAStream-&gt;CR |= DMA_SxCR_HTIE;  /* 半传输中断 */&#10;    }&#10;    if (interrupt &amp; DMA_SxCR_TEIE) {&#10;        DMAStream-&gt;CR |= DMA_SxCR_TEIE;  /* 传输错误中断 */&#10;    }&#10;    if (interrupt &amp; DMA_SxCR_DMEIE) {&#10;        DMAStream-&gt;CR |= DMA_SxCR_DMEIE; /* 直接模式错误中断 */&#10;    }&#10;    if (interrupt &amp; DMA_SxFCR_FEIE) {&#10;        DMAStream-&gt;FCR |= DMA_SxFCR_FEIE; /* FIFO错误中断 */&#10;    }&#10;}&#10;&#10;/**&#10; * @brief Disable DMA interrupt&#10; * &#10; * @details Disables specified DMA interrupts by clearing corresponding bits in the CR register&#10; * &#10; * @param DMAx DMA instance (DMA1 or DMA2)&#10; * @param stream Stream number (0-7)&#10; * @param interrupt Interrupts to disable (combination of DMA_IT_xx flags)&#10; */&#10;void dma_disable_interrupt(DMA_TypeDef *DMAx, uint32_t stream, uint32_t interrupt) {&#10;    DMA_Stream_TypeDef *DMAStream = dma_get_stream(DMAx, stream);&#10;    DMAStream-&gt;CR &amp;= ~interrupt;&#10;}&#10;&#10;/**&#10; * @brief Get DMA transfer complete flag status&#10; * &#10; * @details Checks if the transfer complete flag (TCIF) is set for the specified stream&#10; * &#10; * @param DMAx DMA instance (DMA1 or DMA2)&#10; * @param stream Stream number (0-7)&#10; * @return uint8_t Flag status: 1 if flag is set, 0 otherwise&#10; */&#10;uint8_t dma_get_tc_flag_status(DMA_TypeDef *DMAx, uint32_t stream) {&#10;    uint32_t flag_pos = (stream &lt; 4) ? (6 + stream*6) : (6 + (stream-4)*6 + 16);&#10;    &#10;    if (DMAx == DMA1) {&#10;        return (DMA1-&gt;LISR &amp; (1 &lt;&lt; flag_pos)) ? 1 : 0;&#10;    } else {&#10;        return (DMA2-&gt;LISR &amp; (1 &lt;&lt; flag_pos)) ? 1 : 0;&#10;    }&#10;}&#10;&#10;/**&#10; * @brief Get DMA half transfer flag status&#10; * &#10; * @details Checks if the half transfer flag (HTIF) is set for the specified stream&#10; * &#10; * @param DMAx DMA instance (DMA1 or DMA2)&#10; * @param stream Stream number (0-7)&#10; * @return uint8_t Flag status: 1 if flag is set, 0 otherwise&#10; */&#10;uint8_t dma_get_ht_flag_status(DMA_TypeDef *DMAx, uint32_t stream) {&#10;    uint32_t flag_pos = (stream &lt; 4) ? (4 + stream*6) : (4 + (stream-4)*6 + 16);&#10;    &#10;    if (DMAx == DMA1) {&#10;        return (DMA1-&gt;LISR &amp; (1 &lt;&lt; flag_pos)) ? 1 : 0;&#10;    } else {&#10;        return (DMA2-&gt;LISR &amp; (1 &lt;&lt; flag_pos)) ? 1 : 0;&#10;    }&#10;}&#10;&#10;/**&#10; * @brief Get DMA transfer error flag status&#10; * &#10; * @details Checks if the transfer error flag (TEIF) is set for the specified stream&#10; * &#10; * @param DMAx DMA instance (DMA1 or DMA2)&#10; * @param stream Stream number (0-7)&#10; * @return uint8_t Flag status: 1 if flag is set, 0 otherwise&#10; */&#10;uint8_t dma_get_te_flag_status(DMA_TypeDef *DMAx, uint32_t stream) {&#10;    uint32_t flag_pos = (stream &lt; 4) ? (3 + stream*6) : (3 + (stream-4)*6 + 16);&#10;    &#10;    if (DMAx == DMA1) {&#10;        return (DMA1-&gt;LISR &amp; (1 &lt;&lt; flag_pos)) ? 1 : 0;&#10;    } else {&#10;        return (DMA2-&gt;LISR &amp; (1 &lt;&lt; flag_pos)) ? 1 : 0;&#10;    }&#10;}&#10;&#10;/**&#10; * @brief Clear DMA transfer complete flag&#10; * &#10; * @details Clears the transfer complete flag (TCIF) for the specified stream&#10; * &#10; * @param DMAx DMA instance (DMA1 or DMA2)&#10; * @param stream Stream number (0-7)&#10; */&#10;void dma_clear_tc_flag(DMA_TypeDef *DMAx, uint32_t stream) {&#10;    uint32_t flag_pos = (stream &lt; 4) ? (6 + stream*6) : (6 + (stream-4)*6);&#10;    &#10;    if (DMAx == DMA1) {&#10;        if (stream &lt; 4) {&#10;            DMA1-&gt;LIFCR = (1 &lt;&lt; flag_pos);&#10;        } else {&#10;            DMA1-&gt;HIFCR = (1 &lt;&lt; flag_pos);&#10;        }&#10;    } else {&#10;        if (stream &lt; 4) {&#10;            DMA2-&gt;LIFCR = (1 &lt;&lt; flag_pos);&#10;        } else {&#10;            DMA2-&gt;HIFCR = (1 &lt;&lt; flag_pos);&#10;        }&#10;    }&#10;}&#10;&#10;/**&#10; * @brief Clear DMA half transfer flag&#10; * &#10; * @details Clears the half transfer flag (HTIF) for the specified stream&#10; * &#10; * @param DMAx DMA instance (DMA1 or DMA2)&#10; * @param stream Stream number (0-7)&#10; */&#10;void dma_clear_ht_flag(DMA_TypeDef *DMAx, uint32_t stream) {&#10;    uint32_t flag_pos = (stream &lt; 4) ? (4 + stream*6) : (4 + (stream-4)*6);&#10;    &#10;    if (DMAx == DMA1) {&#10;        if (stream &lt; 4) {&#10;            DMA1-&gt;LIFCR = (1 &lt;&lt; flag_pos);&#10;        } else {&#10;            DMA1-&gt;HIFCR = (1 &lt;&lt; flag_pos);&#10;        }&#10;    } else {&#10;        if (stream &lt; 4) {&#10;            DMA2-&gt;LIFCR = (1 &lt;&lt; flag_pos);&#10;        } else {&#10;            DMA2-&gt;HIFCR = (1 &lt;&lt; flag_pos);&#10;        }&#10;    }&#10;}&#10;&#10;/**&#10; * @brief Clear DMA transfer error flag&#10; * &#10; * @details Clears the transfer error flag (TEIF) for the specified stream&#10; * &#10; * @param DMAx DMA instance (DMA1 or DMA2)&#10; * @param stream Stream number (0-7)&#10; */&#10;void dma_clear_te_flag(DMA_TypeDef *DMAx, uint32_t stream) {&#10;    uint32_t flag_pos = (stream &lt; 4) ? (3 + stream*6) : (3 + (stream-4)*6);&#10;    &#10;    if (DMAx == DMA1) {&#10;        if (stream &lt; 4) {&#10;            DMA1-&gt;LIFCR = (1 &lt;&lt; flag_pos);&#10;        } else {&#10;            DMA1-&gt;HIFCR = (1 &lt;&lt; flag_pos);&#10;        }&#10;    } else {&#10;        if (stream &lt; 4) {&#10;            DMA2-&gt;LIFCR = (1 &lt;&lt; flag_pos);&#10;        } else {&#10;            DMA2-&gt;HIFCR = (1 &lt;&lt; flag_pos);&#10;        }&#10;    }&#10;}&#10;&#10;/**&#10; * @brief Enable DMA clock&#10; * &#10; * @details Sets the appropriate bit in RCC_AHB1ENR register to enable DMA clock&#10; * &#10; * @param DMAx DMA instance (DMA1 or DMA2)&#10; */&#10;void dma_enable_clock(DMA_TypeDef *DMAx) {&#10;    if (DMAx == DMA1) {&#10;        RCC-&gt;AHB1ENR |= RCC_AHB1ENR_DMA1EN;&#10;    } else {&#10;        RCC-&gt;AHB1ENR |= RCC_AHB1ENR_DMA2EN;&#10;    }&#10;}&#10;&#10;/**&#10; * @brief Get number of data items left to transfer&#10; * &#10; * @details Reads the current NDTR register value to get number of remaining transfers&#10; * &#10; * @param DMAx DMA instance (DMA1 or DMA2)&#10; * @param stream Stream number (0-7)&#10; * @return uint16_t Number of data items left to transfer&#10; */&#10;uint16_t dma_get_counter(DMA_TypeDef *DMAx, uint32_t stream) {&#10;    DMA_Stream_TypeDef *DMAStream = dma_get_stream(DMAx, stream);&#10;    return (uint16_t)DMAStream-&gt;NDTR;&#10;}&#10;" />
              <option name="updatedContent" value="/**&#10; * @file dma.c&#10; * @author Haoyi Chen&#10; * @date 2025-08-08&#10; * @brief STM32F4 DMA register-level driver&#10; *&#10; * @details This file provides basic DMA initialization, configuration and operation&#10; * functions for STM32F407 series microcontrollers. All operations are performed at the &#10; * register level, without using HAL or LL libraries.&#10; *&#10; * Created for personal learning and embedded systems experimentation.&#10; */&#10;&#10;#include &quot;dma.h&quot;&#10;&#10;/**&#10; * @brief Get DMA stream register pointer&#10; * &#10; * @details Helper function to get pointer to the right stream register set&#10; * &#10; * @param DMAx DMA instance (DMA1 or DMA2)&#10; * @param stream Stream number (0-7)&#10; * @return DMA_Stream_TypeDef* Pointer to the DMA stream registers&#10; */&#10;static DMA_Stream_TypeDef* dma_get_stream(DMA_TypeDef *DMAx, uint32_t stream) {&#10;    return (DMA_Stream_TypeDef *)((uint32_t)((uint32_t)DMAx + 0x10 + (0x18 * stream)));&#10;}&#10;&#10;/**&#10; * @brief Initialize DMA stream with the specified parameters&#10; * &#10; * @details Configures DMA stream by setting channel, direction, increment modes,&#10; *          data alignment, mode, priority, and FIFO settings.&#10; *&#10; * @param DMAx DMA instance (DMA1 or DMA2)&#10; * @param stream Stream number (0-7)&#10; * @param init Pointer to DMA initialization structure&#10; * &#10; * @note DMA clock must be enabled separately via RCC registers before calling this function&#10; */&#10;void dma_init(DMA_TypeDef *DMAx, uint32_t stream, DMA_InitTypeDef *init) {&#10;    DMA_Stream_TypeDef *DMAStream = dma_get_stream(DMAx, stream);&#10;    &#10;    /* Disable the DMA Stream first */&#10;    DMAStream-&gt;CR &amp;= ~DMA_SxCR_EN;&#10;    &#10;    /* Wait until the stream is effectively disabled */&#10;    while(DMAStream-&gt;CR &amp; DMA_SxCR_EN);&#10;    &#10;    /* Clear all interrupt flags for the selected stream */&#10;    /* This is critical for proper DMA operation */&#10;    if (DMAx == DMA1) {&#10;        if (stream &lt; 4) {&#10;            /* Streams 0-3 use LIFCR register */&#10;            DMA1-&gt;LIFCR = (0x3F &lt;&lt; (stream * 6)); /* Clear all flags for this stream */&#10;        } else {&#10;            /* Streams 4-7 use HIFCR register */&#10;            DMA1-&gt;HIFCR = (0x3F &lt;&lt; ((stream - 4) * 6)); /* Clear all flags for this stream */&#10;        }&#10;    } else { /* DMA2 */&#10;        if (stream &lt; 4) {&#10;            /* Streams 0-3 use LIFCR register */&#10;            DMA2-&gt;LIFCR = (0x3F &lt;&lt; (stream * 6)); /* Clear all flags for this stream */&#10;        } else {&#10;            /* Streams 4-7 use HIFCR register */&#10;            DMA2-&gt;HIFCR = (0x3F &lt;&lt; ((stream - 4) * 6)); /* Clear all flags for this stream */&#10;        }&#10;    }&#10;    &#10;    /* Configure the source, destination and buffer size */&#10;    DMAStream-&gt;PAR = 0;&#10;    DMAStream-&gt;M0AR = 0;&#10;    DMAStream-&gt;NDTR = 0;&#10;    &#10;    /* Configure CR register - do this in one write operation */&#10;    DMAStream-&gt;CR = init-&gt;Channel | init-&gt;Direction | init-&gt;PeriphInc | init-&gt;MemInc |&#10;                    init-&gt;PeriphDataAlign | init-&gt;MemDataAlign | init-&gt;Mode | init-&gt;Priority;&#10;    &#10;    /* Configure FIFO */&#10;    DMAStream-&gt;FCR = init-&gt;FIFOMode | init-&gt;FIFOThreshold | init-&gt;MemBurst | init-&gt;PeriphBurst;&#10;}&#10;&#10;/**&#10; * @brief Configure DMA transfer parameters&#10; * &#10; * @details Sets up source and destination addresses and transfer count for DMA operation&#10; *&#10; * @param DMAx DMA instance (DMA1 or DMA2)&#10; * @param stream Stream number (0-7)&#10; * @param SrcAddress Source address&#10; * @param DstAddress Destination address&#10; * @param DataLength Number of data items to transfer&#10; * &#10; * @note This function should be called after dma_init&#10; */&#10;void dma_config_transfer(DMA_TypeDef *DMAx, uint32_t stream, uint32_t SrcAddress, uint32_t DstAddress, uint16_t DataLength) {&#10;    DMA_Stream_TypeDef *DMAStream = dma_get_stream(DMAx, stream);&#10;    &#10;    /* Make sure the stream is disabled */&#10;    if (DMAStream-&gt;CR &amp; DMA_SxCR_EN) {&#10;        DMAStream-&gt;CR &amp;= ~DMA_SxCR_EN;&#10;        while(DMAStream-&gt;CR &amp; DMA_SxCR_EN);&#10;    }&#10;    &#10;    /* Clear any pending flags for this stream before configuration */&#10;    if (DMAx == DMA1) {&#10;        if (stream &lt; 4) {&#10;            DMA1-&gt;LIFCR = (0x3F &lt;&lt; (stream * 6)); /* Clear all flags for this stream */&#10;        } else {&#10;            DMA1-&gt;HIFCR = (0x3F &lt;&lt; ((stream - 4) * 6)); /* Clear all flags for this stream */&#10;        }&#10;    } else { /* DMA2 */&#10;        if (stream &lt; 4) {&#10;            DMA2-&gt;LIFCR = (0x3F &lt;&lt; (stream * 6)); /* Clear all flags for this stream */&#10;        } else {&#10;            DMA2-&gt;HIFCR = (0x3F &lt;&lt; ((stream - 4) * 6)); /* Clear all flags for this stream */&#10;        }&#10;    }&#10;    &#10;    /* Configure source, destination and data length according to direction */&#10;    uint32_t direction = DMAStream-&gt;CR &amp; DMA_SxCR_DIR;&#10;    &#10;    if (direction == DMA_PERIPH_TO_MEMORY) {&#10;        /* Peripheral to memory (e.g., ADC to RAM) */&#10;        DMAStream-&gt;PAR = SrcAddress;    /* Peripheral is source (e.g., ADC data register) */&#10;        DMAStream-&gt;M0AR = DstAddress;   /* Memory is destination (e.g., buffer array) */&#10;    } else if (direction == DMA_MEMORY_TO_PERIPH) {&#10;        /* Memory to peripheral (e.g., RAM to DAC) */&#10;        DMAStream-&gt;PAR = DstAddress;    /* Peripheral is destination (e.g., DAC data register) */&#10;        DMAStream-&gt;M0AR = SrcAddress;   /* Memory is source (e.g., buffer array) */&#10;    } else if (direction == DMA_MEMORY_TO_MEMORY) {&#10;        /* Memory to memory */&#10;        DMAStream-&gt;PAR = SrcAddress;    /* Source memory address */&#10;        DMAStream-&gt;M0AR = DstAddress;   /* Destination memory address */&#10;    }&#10;    &#10;    /* Set data length - verify it's within limits first */&#10;    if (DataLength &gt; 0 &amp;&amp; DataLength &lt;= 65535) {&#10;        DMAStream-&gt;NDTR = DataLength;   /* Number of data items to transfer */&#10;    } else {&#10;        /* Handle invalid length - default to a safe value */&#10;        DMAStream-&gt;NDTR = 1;            /* Set to minimum safe value */&#10;    }&#10;}&#10;&#10;/**&#10; * @brief Enable DMA stream&#10; * &#10; * @details Sets the EN bit in the DMA_SxCR register to start DMA transfer&#10; * &#10; * @param DMAx DMA instance (DMA1 or DMA2)&#10; * @param stream Stream number (0-7)&#10; */&#10;void dma_enable(DMA_TypeDef *DMAx, uint32_t stream) {&#10;    DMA_Stream_TypeDef *DMAStream = dma_get_stream(DMAx, stream);&#10;    DMAStream-&gt;CR |= DMA_SxCR_EN;&#10;}&#10;&#10;/**&#10; * @brief Disable DMA stream&#10; * &#10; * @details Clears the EN bit in the DMA_SxCR register to stop DMA transfer&#10; * &#10; * @param DMAx DMA instance (DMA1 or DMA2)&#10; * @param stream Stream number (0-7)&#10; */&#10;void dma_disable(DMA_TypeDef *DMAx, uint32_t stream) {&#10;    DMA_Stream_TypeDef *DMAStream = dma_get_stream(DMAx, stream);&#10;    DMAStream-&gt;CR &amp;= ~DMA_SxCR_EN;&#10;}&#10;&#10;/**&#10; * @brief Enable DMA interrupt&#10; * &#10; * @details Enables specified DMA interrupts by setting corresponding bits in the CR register&#10; * &#10; * @param DMAx DMA instance (DMA1 or DMA2)&#10; * @param stream Stream number (0-7)&#10; * @param interrupt Combination of interrupt flags to enable, use system macros directly:&#10; *                  DMA_SxCR_TCIE - Transfer Complete Interrupt&#10; *                  DMA_SxCR_HTIE - Half Transfer Interrupt&#10; *                  DMA_SxCR_TEIE - Transfer Error Interrupt&#10; *                  DMA_SxCR_DMEIE - Direct Mode Error Interrupt&#10; *                  DMA_SxFCR_FEIE - FIFO Error Interrupt&#10; *                  Multiple interrupts can be combined with bitwise OR (|)&#10; */&#10;void dma_enable_interrupt(DMA_TypeDef *DMAx, uint32_t stream, uint32_t interrupt) {&#10;    DMA_Stream_TypeDef *DMAStream = dma_get_stream(DMAx, stream);&#10;    &#10;    /* Process interrupt flags in CR register */&#10;    uint32_t cr_interrupts = interrupt &amp; (DMA_SxCR_TCIE | DMA_SxCR_HTIE | DMA_SxCR_TEIE | DMA_SxCR_DMEIE);&#10;    if (cr_interrupts) {&#10;        DMAStream-&gt;CR |= cr_interrupts;&#10;    }&#10;    &#10;    /* Process interrupt flags in FCR register */&#10;    if (interrupt &amp; DMA_SxFCR_FEIE) {&#10;        DMAStream-&gt;FCR |= DMA_SxFCR_FEIE;&#10;    }&#10;}&#10;&#10;/**&#10; * @brief Disable DMA interrupt&#10; * &#10; * @details Disables specified DMA interrupts by clearing corresponding bits in the CR register&#10; * &#10; * @param DMAx DMA instance (DMA1 or DMA2)&#10; * @param stream Stream number (0-7)&#10; * @param interrupt Combination of interrupt flags to disable, use system macros directly:&#10; *                  DMA_SxCR_TCIE - Transfer Complete Interrupt&#10; *                  DMA_SxCR_HTIE - Half Transfer Interrupt&#10; *                  DMA_SxCR_TEIE - Transfer Error Interrupt&#10; *                  DMA_SxCR_DMEIE - Direct Mode Error Interrupt&#10; *                  DMA_SxFCR_FEIE - FIFO Error Interrupt&#10; *                  Multiple interrupts can be combined with bitwise OR (|)&#10; */&#10;void dma_disable_interrupt(DMA_TypeDef *DMAx, uint32_t stream, uint32_t interrupt) {&#10;    DMA_Stream_TypeDef *DMAStream = dma_get_stream(DMAx, stream);&#10;    &#10;    /* Process interrupt flags in CR register */&#10;    uint32_t cr_interrupts = interrupt &amp; (DMA_SxCR_TCIE | DMA_SxCR_HTIE | DMA_SxCR_TEIE | DMA_SxCR_DMEIE);&#10;    if (cr_interrupts) {&#10;        DMAStream-&gt;CR &amp;= ~cr_interrupts;&#10;    }&#10;    &#10;    /* Process interrupt flags in FCR register */&#10;    if (interrupt &amp; DMA_SxFCR_FEIE) {&#10;        DMAStream-&gt;FCR &amp;= ~DMA_SxFCR_FEIE;&#10;    }&#10;}&#10;&#10;/**&#10; * @brief Get DMA transfer complete flag status&#10; * &#10; * @details Checks if the transfer complete flag (TCIF) is set for the specified stream&#10; * &#10; * @param DMAx DMA instance (DMA1 or DMA2)&#10; * @param stream Stream number (0-7)&#10; * @return uint8_t Flag status: 1 if flag is set, 0 otherwise&#10; */&#10;uint8_t dma_get_tc_flag_status(DMA_TypeDef *DMAx, uint32_t stream) {&#10;    uint32_t flag_pos = (stream &lt; 4) ? (6 + stream*6) : (6 + (stream-4)*6 + 16);&#10;    &#10;    if (DMAx == DMA1) {&#10;        return (DMA1-&gt;LISR &amp; (1 &lt;&lt; flag_pos)) ? 1 : 0;&#10;    } else {&#10;        return (DMA2-&gt;LISR &amp; (1 &lt;&lt; flag_pos)) ? 1 : 0;&#10;    }&#10;}&#10;&#10;/**&#10; * @brief Get DMA half transfer flag status&#10; * &#10; * @details Checks if the half transfer flag (HTIF) is set for the specified stream&#10; * &#10; * @param DMAx DMA instance (DMA1 or DMA2)&#10; * @param stream Stream number (0-7)&#10; * @return uint8_t Flag status: 1 if flag is set, 0 otherwise&#10; */&#10;uint8_t dma_get_ht_flag_status(DMA_TypeDef *DMAx, uint32_t stream) {&#10;    uint32_t flag_pos = (stream &lt; 4) ? (4 + stream*6) : (4 + (stream-4)*6 + 16);&#10;    &#10;    if (DMAx == DMA1) {&#10;        return (DMA1-&gt;LISR &amp; (1 &lt;&lt; flag_pos)) ? 1 : 0;&#10;    } else {&#10;        return (DMA2-&gt;LISR &amp; (1 &lt;&lt; flag_pos)) ? 1 : 0;&#10;    }&#10;}&#10;&#10;/**&#10; * @brief Get DMA transfer error flag status&#10; * &#10; * @details Checks if the transfer error flag (TEIF) is set for the specified stream&#10; * &#10; * @param DMAx DMA instance (DMA1 or DMA2)&#10; * @param stream Stream number (0-7)&#10; * @return uint8_t Flag status: 1 if flag is set, 0 otherwise&#10; */&#10;uint8_t dma_get_te_flag_status(DMA_TypeDef *DMAx, uint32_t stream) {&#10;    uint32_t flag_pos = (stream &lt; 4) ? (3 + stream*6) : (3 + (stream-4)*6 + 16);&#10;    &#10;    if (DMAx == DMA1) {&#10;        return (DMA1-&gt;LISR &amp; (1 &lt;&lt; flag_pos)) ? 1 : 0;&#10;    } else {&#10;        return (DMA2-&gt;LISR &amp; (1 &lt;&lt; flag_pos)) ? 1 : 0;&#10;    }&#10;}&#10;&#10;/**&#10; * @brief Clear DMA transfer complete flag&#10; * &#10; * @details Clears the transfer complete flag (TCIF) for the specified stream&#10; * &#10; * @param DMAx DMA instance (DMA1 or DMA2)&#10; * @param stream Stream number (0-7)&#10; */&#10;void dma_clear_tc_flag(DMA_TypeDef *DMAx, uint32_t stream) {&#10;    uint32_t flag_pos = (stream &lt; 4) ? (6 + stream*6) : (6 + (stream-4)*6);&#10;    &#10;    if (DMAx == DMA1) {&#10;        if (stream &lt; 4) {&#10;            DMA1-&gt;LIFCR = (1 &lt;&lt; flag_pos);&#10;        } else {&#10;            DMA1-&gt;HIFCR = (1 &lt;&lt; flag_pos);&#10;        }&#10;    } else {&#10;        if (stream &lt; 4) {&#10;            DMA2-&gt;LIFCR = (1 &lt;&lt; flag_pos);&#10;        } else {&#10;            DMA2-&gt;HIFCR = (1 &lt;&lt; flag_pos);&#10;        }&#10;    }&#10;}&#10;&#10;/**&#10; * @brief Clear DMA half transfer flag&#10; * &#10; * @details Clears the half transfer flag (HTIF) for the specified stream&#10; * &#10; * @param DMAx DMA instance (DMA1 or DMA2)&#10; * @param stream Stream number (0-7)&#10; */&#10;void dma_clear_ht_flag(DMA_TypeDef *DMAx, uint32_t stream) {&#10;    uint32_t flag_pos = (stream &lt; 4) ? (4 + stream*6) : (4 + (stream-4)*6);&#10;    &#10;    if (DMAx == DMA1) {&#10;        if (stream &lt; 4) {&#10;            DMA1-&gt;LIFCR = (1 &lt;&lt; flag_pos);&#10;        } else {&#10;            DMA1-&gt;HIFCR = (1 &lt;&lt; flag_pos);&#10;        }&#10;    } else {&#10;        if (stream &lt; 4) {&#10;            DMA2-&gt;LIFCR = (1 &lt;&lt; flag_pos);&#10;        } else {&#10;            DMA2-&gt;HIFCR = (1 &lt;&lt; flag_pos);&#10;        }&#10;    }&#10;}&#10;&#10;/**&#10; * @brief Clear DMA transfer error flag&#10; * &#10; * @details Clears the transfer error flag (TEIF) for the specified stream&#10; * &#10; * @param DMAx DMA instance (DMA1 or DMA2)&#10; * @param stream Stream number (0-7)&#10; */&#10;void dma_clear_te_flag(DMA_TypeDef *DMAx, uint32_t stream) {&#10;    uint32_t flag_pos = (stream &lt; 4) ? (3 + stream*6) : (3 + (stream-4)*6);&#10;    &#10;    if (DMAx == DMA1) {&#10;        if (stream &lt; 4) {&#10;            DMA1-&gt;LIFCR = (1 &lt;&lt; flag_pos);&#10;        } else {&#10;            DMA1-&gt;HIFCR = (1 &lt;&lt; flag_pos);&#10;        }&#10;    } else {&#10;        if (stream &lt; 4) {&#10;            DMA2-&gt;LIFCR = (1 &lt;&lt; flag_pos);&#10;        } else {&#10;            DMA2-&gt;HIFCR = (1 &lt;&lt; flag_pos);&#10;        }&#10;    }&#10;}&#10;&#10;/**&#10; * @brief Enable DMA clock&#10; * &#10; * @details Sets the appropriate bit in RCC_AHB1ENR register to enable DMA clock&#10; * &#10; * @param DMAx DMA instance (DMA1 or DMA2)&#10; */&#10;void dma_enable_clock(DMA_TypeDef *DMAx) {&#10;    if (DMAx == DMA1) {&#10;        RCC-&gt;AHB1ENR |= RCC_AHB1ENR_DMA1EN;&#10;    } else {&#10;        RCC-&gt;AHB1ENR |= RCC_AHB1ENR_DMA2EN;&#10;    }&#10;}&#10;&#10;/**&#10; * @brief Get number of data items left to transfer&#10; * &#10; * @details Reads the current NDTR register value to get number of remaining transfers&#10; * &#10; * @param DMAx DMA instance (DMA1 or DMA2)&#10; * @param stream Stream number (0-7)&#10; * @return uint16_t Number of data items left to transfer&#10; */&#10;uint16_t dma_get_counter(DMA_TypeDef *DMAx, uint32_t stream) {&#10;    DMA_Stream_TypeDef *DMAStream = dma_get_stream(DMAx, stream);&#10;    return (uint16_t)DMAStream-&gt;NDTR;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Src/i2c.c">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Src/i2c.c" />
              <option name="updatedContent" value="// filepath: /Users/haoyi/Documents/Code/Electronics_for_embedded_systems/Motor_monitor/Software/Src/i2c.c&#10;/**&#10; * @file i2c.c&#10; * @author Haoyi Chen&#10; * @date 2025-08-08&#10; * @brief STM32F4 I2C register-level driver&#10; *&#10; * @details This file provides basic I2C initialization, transmit, receive and memory access&#10; * functions for STM32F407 series microcontrollers. All operations are performed at the&#10; * register level, without using HAL or LL libraries.&#10; *&#10; * Created for personal learning and embedded systems experimentation.&#10; */&#10;&#10;#include &quot;i2c.h&quot;&#10;#include &quot;gpio.h&quot;&#10;&#10;/**&#10; * @brief Initialize I2C with the specified parameters&#10; * &#10; * @details Configures I2C by setting clock speed, addressing mode, duty cycle and other parameters&#10; *&#10; * @param I2Cx I2C instance (I2C1, I2C2, or I2C3)&#10; * @param init Pointer to I2C initialization structure&#10; * &#10; * @note I2C clock must be enabled separately via RCC registers before calling this function&#10; */&#10;void i2c_init(I2C_TypeDef *I2Cx, I2C_InitTypeDef *init) {&#10;    uint32_t pclk1 = 0;&#10;    uint32_t freqrange = 0;&#10;    &#10;    /* Disable I2C first */&#10;    I2Cx-&gt;CR1 &amp;= ~I2C_CR1_PE;&#10;    &#10;    /* Get PCLK1 frequency */&#10;    // Assuming a function like this exists in your RCC module&#10;    // In real implementation, you should use your own RCC function&#10;    // pclk1 = rcc_get_pclk1_freq();&#10;    &#10;    // For now, using a fixed value - this should be replaced with actual PCLK1 frequency&#10;    pclk1 = 42000000; // 42 MHz (typical PCLK1 for STM32F407 at maximum speed)&#10;    &#10;    /* I2C peripheral configuration */&#10;    &#10;    /* Configure I2C CR2 register: frequency */&#10;    freqrange = (uint32_t)(pclk1 / 1000000);&#10;    I2Cx-&gt;CR2 = freqrange; // PCLK1 frequency in MHz&#10;    &#10;    /* Configure I2C CCR register: Clock control */&#10;    I2Cx-&gt;CCR = 0; // Clear CCR register&#10;    &#10;    /* Configure speed in standard mode */&#10;    if (init-&gt;ClockSpeed &lt;= 100000) {&#10;        /* Standard mode speed calculation */&#10;        I2Cx-&gt;CCR |= (uint16_t)((pclk1 / (init-&gt;ClockSpeed * 2)));&#10;        &#10;        /* Set maximum rise time in standard mode */&#10;        I2Cx-&gt;TRISE = freqrange + 1;&#10;    }&#10;    /* Configure speed in fast mode */&#10;    else {&#10;        /* Fast mode speed calculation */&#10;        &#10;        /* Configure duty cycle */&#10;        I2Cx-&gt;CCR |= init-&gt;DutyCycle;&#10;        &#10;        /* Set FAST mode bit */&#10;        I2Cx-&gt;CCR |= I2C_CCR_FS;&#10;        &#10;        /* Fast mode speed calculation based on duty cycle */&#10;        if (init-&gt;DutyCycle == I2C_DUTYCYCLE_2) {&#10;            I2Cx-&gt;CCR |= (uint16_t)(pclk1 / (init-&gt;ClockSpeed * 3));&#10;        }&#10;        else { // I2C_DUTYCYCLE_16_9&#10;            I2Cx-&gt;CCR |= (uint16_t)(pclk1 / (init-&gt;ClockSpeed * 25));&#10;        }&#10;        &#10;        /* Set maximum rise time in fast mode */&#10;        I2Cx-&gt;TRISE = (uint16_t)((freqrange * 300) / 1000) + 1;&#10;    }&#10;    &#10;    /* Configure I2C OAR1 register: Own Address 1 */&#10;    I2Cx-&gt;OAR1 = (init-&gt;AddressingMode | (init-&gt;OwnAddress1 &lt;&lt; 1));&#10;    &#10;    /* Configure I2C OAR2 register: Dual mode and Own Address 2 */&#10;    I2Cx-&gt;OAR2 = (init-&gt;DualAddressMode | (init-&gt;OwnAddress2 &lt;&lt; 1));&#10;    &#10;    /* Configure I2C CR1 register */&#10;    I2Cx-&gt;CR1 |= (init-&gt;GeneralCallMode | init-&gt;NoStretchMode);&#10;    &#10;    /* Enable I2C */&#10;    I2Cx-&gt;CR1 |= I2C_CR1_PE;&#10;}&#10;&#10;/**&#10; * @brief Initialize GPIO pins for I2C&#10; * &#10; * @details Configures GPIO pins in alternate function open-drain mode for SCL and SDA&#10; *&#10; * @param I2Cx I2C instance (I2C1, I2C2, or I2C3)&#10; * @param GPIOx GPIO port for SCL and SDA pins (GPIOA, GPIOB, etc.)&#10; * @param SCL_Pin SCL pin number (0-15)&#10; * @param SDA_Pin SDA pin number (0-15)&#10; * &#10; * @note GPIO clock must be enabled separately via RCC registers&#10; */&#10;void i2c_gpio_init(I2C_TypeDef *I2Cx, GPIO_TypeDef *GPIOx, uint8_t SCL_Pin, uint8_t SDA_Pin) {&#10;    uint8_t alternate_function;&#10;    &#10;    /* Determine alternate function number based on I2C instance */&#10;    if (I2Cx == I2C1 || I2Cx == I2C2) {&#10;        alternate_function = 4; // AF4 for I2C1 and I2C2&#10;    } else {&#10;        alternate_function = 9; // AF9 for I2C3&#10;    }&#10;    &#10;    /* Configure SCL pin: Alternate function Open-Drain */&#10;    gpio_init(GPIOx, SCL_Pin, 0x02, 0x01, 0x03, 0x00); // AF mode, open drain, high speed, no pull&#10;    gpio_set_alternate_function(GPIOx, SCL_Pin, alternate_function);&#10;    &#10;    /* Configure SDA pin: Alternate function Open-Drain */&#10;    gpio_init(GPIOx, SDA_Pin, 0x02, 0x01, 0x03, 0x00); // AF mode, open drain, high speed, no pull&#10;    gpio_set_alternate_function(GPIOx, SDA_Pin, alternate_function);&#10;}&#10;&#10;/**&#10; * @brief Check if the I2C bus is free&#10; * &#10; * @details Reads the BUSY bit in SR2 register to determine if the bus is busy&#10; * &#10; * @param I2Cx I2C instance (I2C1, I2C2, or I2C3)&#10; * @return uint8_t 1 if bus is free, 0 if busy&#10; */&#10;uint8_t i2c_is_bus_free(I2C_TypeDef *I2Cx) {&#10;    /* Check if the bus is busy */&#10;    if ((I2Cx-&gt;SR2 &amp; I2C_FLAG_BUSY) == I2C_FLAG_BUSY) {&#10;        return 0; // Bus is busy&#10;    }&#10;    return 1; // Bus is free&#10;}&#10;&#10;/**&#10; * @brief Wait for a specific I2C flag to be set or reset&#10; * &#10; * @details Waits for a flag in SR1 or SR2 register to reach expected state with timeout&#10; * &#10; * @param I2Cx I2C instance (I2C1, I2C2, or I2C3)&#10; * @param flag Flag to check&#10; * @param status Expected status (1 for set, 0 for reset)&#10; * @param timeout Timeout value&#10; * @return uint8_t 0 if successful (flag matched expected state), 1 if timeout&#10; */&#10;uint8_t i2c_wait_flag(I2C_TypeDef *I2Cx, uint32_t flag, uint8_t status, uint32_t timeout) {&#10;    uint32_t tickstart = 0;&#10;    &#10;    /* Get current tick count */&#10;    // Assuming a millisecond tick counter exists&#10;    tickstart = 0; // Replace with actual tick counter&#10;    &#10;    /* Flag is in SR2 register */&#10;    if (flag &gt; 0xFFFF) {&#10;        while ((((I2Cx-&gt;SR2 &amp; (flag &amp; 0xFFFF)) == (flag &amp; 0xFFFF)) ? 1 : 0) != status) {&#10;            /* Check for timeout */&#10;            if (timeout != 0 &amp;&amp; ((0 - tickstart) &gt; timeout)) { // Replace with actual tick calculation&#10;                return 1; // Timeout&#10;            }&#10;        }&#10;    }&#10;    /* Flag is in SR1 register */&#10;    else {&#10;        while ((((I2Cx-&gt;SR1 &amp; flag) == flag) ? 1 : 0) != status) {&#10;            /* Check for timeout */&#10;            if (timeout != 0 &amp;&amp; ((0 - tickstart) &gt; timeout)) { // Replace with actual tick calculation&#10;                return 1; // Timeout&#10;            }&#10;        }&#10;    }&#10;    &#10;    return 0; // Flag matched expected state&#10;}&#10;&#10;/**&#10; * @brief Generate start condition on I2C bus&#10; * &#10; * @details Sets START bit in CR1 register and waits for SB bit to be set&#10; * &#10; * @param I2Cx I2C instance (I2C1, I2C2, or I2C3)&#10; * @return uint8_t 0 if successful, 1 if error&#10; */&#10;uint8_t i2c_generate_start(I2C_TypeDef *I2Cx) {&#10;    /* Generate start condition */&#10;    I2Cx-&gt;CR1 |= I2C_CR1_START;&#10;    &#10;    /* Wait until SB flag is set */&#10;    if (i2c_wait_flag(I2Cx, I2C_FLAG_SB, 1, I2C_TIMEOUT_FLAG) != 0) {&#10;        return 1; // Error&#10;    }&#10;    &#10;    return 0; // Success&#10;}&#10;&#10;/**&#10; * @brief Generate stop condition on I2C bus&#10; * &#10; * @details Sets STOP bit in CR1 register&#10; * &#10; * @param I2Cx I2C instance (I2C1, I2C2, or I2C3)&#10; * @return uint8_t 0 if successful, 1 if error&#10; */&#10;uint8_t i2c_generate_stop(I2C_TypeDef *I2Cx) {&#10;    /* Generate stop condition */&#10;    I2Cx-&gt;CR1 |= I2C_CR1_STOP;&#10;    &#10;    return 0; // Success&#10;}&#10;&#10;/**&#10; * @brief Send 7-bit or 10-bit device address&#10; * &#10; * @details Sends device address with R/W bit according to direction&#10; * &#10; * @param I2Cx I2C instance (I2C1, I2C2, or I2C3)&#10; * @param DevAddress Target device address&#10; * @param Direction Direction (I2C_DIRECTION_TRANSMIT or I2C_DIRECTION_RECEIVE)&#10; * @return uint8_t 0 if successful, 1 if error&#10; */&#10;uint8_t i2c_send_address(I2C_TypeDef *I2Cx, uint16_t DevAddress, uint8_t Direction) {&#10;    /* 7-bit addressing mode */&#10;    if ((I2Cx-&gt;OAR1 &amp; I2C_OAR1_ADDMODE) == 0) {&#10;        /* Send slave address with R/W bit */&#10;        I2Cx-&gt;DR = (uint8_t)((DevAddress &lt;&lt; 1) | Direction);&#10;    }&#10;    /* 10-bit addressing mode */&#10;    else {&#10;        /* Send header for 10-bit addressing */&#10;        I2Cx-&gt;DR = (uint8_t)(((DevAddress &gt;&gt; 7) &lt;&lt; 1) | 0xF0);&#10;        &#10;        /* Wait until ADD10 flag is set */&#10;        if (i2c_wait_flag(I2Cx, I2C_FLAG_ADD10, 1, I2C_TIMEOUT_FLAG) != 0) {&#10;            return 1; // Error&#10;        }&#10;        &#10;        /* Send slave address (2nd part) */&#10;        I2Cx-&gt;DR = (uint8_t)(DevAddress &amp; 0xFF);&#10;        &#10;        /* If direction is receive, generate repeated START condition */&#10;        if (Direction == I2C_DIRECTION_RECEIVE) {&#10;            /* Wait until ADDR flag is set */&#10;            if (i2c_wait_flag(I2Cx, I2C_FLAG_ADDR, 1, I2C_TIMEOUT_FLAG) != 0) {&#10;                return 1; // Error&#10;            }&#10;            &#10;            /* Clear ADDR flag */&#10;            __IO uint32_t tmp = I2Cx-&gt;SR2;&#10;            (void)tmp;&#10;            &#10;            /* Generate repeated start condition */&#10;            I2Cx-&gt;CR1 |= I2C_CR1_START;&#10;            &#10;            /* Wait until SB flag is set */&#10;            if (i2c_wait_flag(I2Cx, I2C_FLAG_SB, 1, I2C_TIMEOUT_FLAG) != 0) {&#10;                return 1; // Error&#10;            }&#10;            &#10;            /* Send header for 10-bit addressing (with READ bit) */&#10;            I2Cx-&gt;DR = (uint8_t)(((DevAddress &gt;&gt; 7) &lt;&lt; 1) | 0xF1);&#10;        }&#10;    }&#10;    &#10;    /* Wait until ADDR flag is set */&#10;    if (i2c_wait_flag(I2Cx, I2C_FLAG_ADDR, 1, I2C_TIMEOUT_FLAG) != 0) {&#10;        return 1; // Error&#10;    }&#10;    &#10;    /* Clear ADDR flag */&#10;    __IO uint32_t tmp = I2Cx-&gt;SR1;&#10;    tmp = I2Cx-&gt;SR2; // Read SR1 then SR2 to clear ADDR flag&#10;    (void)tmp;&#10;    &#10;    return 0; // Success&#10;}&#10;&#10;/**&#10; * @brief Master transmit data to a slave device&#10; * &#10; * @details Initiates transmission with START condition, sends data bytes, and generates STOP&#10; * &#10; * @param I2Cx I2C instance (I2C1, I2C2, or I2C3)&#10; * @param DevAddress Target device address&#10; * @param pData Pointer to data buffer&#10; * @param Size Amount of data to be sent&#10; * @param Timeout Timeout value&#10; * @return uint8_t 0 if successful, 1 if error&#10; */&#10;uint8_t i2c_master_transmit(I2C_TypeDef *I2Cx, uint16_t DevAddress, uint8_t *pData, uint16_t Size, uint32_t Timeout) {&#10;    /* Check parameters */&#10;    if (Size == 0 || pData == NULL) {&#10;        return 1; // Error: Invalid parameters&#10;    }&#10;    &#10;    /* Wait until bus is free */&#10;    if (i2c_wait_flag(I2Cx, I2C_FLAG_BUSY, 0, I2C_TIMEOUT_BUSY_FLAG) != 0) {&#10;        return 1; // Error: Bus is busy&#10;    }&#10;    &#10;    /* Generate START condition */&#10;    if (i2c_generate_start(I2Cx) != 0) {&#10;        return 1; // Error generating START&#10;    }&#10;    &#10;    /* Send slave address (for write) */&#10;    if (i2c_send_address(I2Cx, DevAddress, I2C_DIRECTION_TRANSMIT) != 0) {&#10;        i2c_generate_stop(I2Cx);&#10;        return 1; // Error sending address&#10;    }&#10;    &#10;    /* Send data */&#10;    while (Size &gt; 0) {&#10;        /* Wait until TXE flag is set */&#10;        if (i2c_wait_flag(I2Cx, I2C_FLAG_TXE, 1, Timeout) != 0) {&#10;            i2c_generate_stop(I2Cx);&#10;            return 1; // Error: TXE timeout&#10;        }&#10;        &#10;        /* Write data to DR */&#10;        I2Cx-&gt;DR = *pData;&#10;        pData++;&#10;        Size--;&#10;        &#10;        /* Wait until BTF flag is set for last byte */&#10;        if (Size == 0) {&#10;            if (i2c_wait_flag(I2Cx, I2C_FLAG_BTF, 1, Timeout) != 0) {&#10;                i2c_generate_stop(I2Cx);&#10;                return 1; // Error: BTF timeout&#10;            }&#10;        }&#10;    }&#10;    &#10;    /* Generate STOP condition */&#10;    i2c_generate_stop(I2Cx);&#10;    &#10;    return 0; // Success&#10;}&#10;&#10;/**&#10; * @brief Master receive data from a slave device&#10; * &#10; * @details Initiates reception with START condition, receives data bytes, and generates STOP&#10; * &#10; * @param I2Cx I2C instance (I2C1, I2C2, or I2C3)&#10; * @param DevAddress Target device address&#10; * @param pData Pointer to data buffer&#10; * @param Size Amount of data to be received&#10; * @param Timeout Timeout value&#10; * @return uint8_t 0 if successful, 1 if error&#10; */&#10;uint8_t i2c_master_receive(I2C_TypeDef *I2Cx, uint16_t DevAddress, uint8_t *pData, uint16_t Size, uint32_t Timeout) {&#10;    /* Check parameters */&#10;    if (Size == 0 || pData == NULL) {&#10;        return 1; // Error: Invalid parameters&#10;    }&#10;    &#10;    /* Wait until bus is free */&#10;    if (i2c_wait_flag(I2Cx, I2C_FLAG_BUSY, 0, I2C_TIMEOUT_BUSY_FLAG) != 0) {&#10;        return 1; // Error: Bus is busy&#10;    }&#10;    &#10;    /* Enable Acknowledge */&#10;    I2Cx-&gt;CR1 |= I2C_CR1_ACK;&#10;    &#10;    /* Generate START condition */&#10;    if (i2c_generate_start(I2Cx) != 0) {&#10;        return 1; // Error generating START&#10;    }&#10;    &#10;    /* Send slave address (for read) */&#10;    if (i2c_send_address(I2Cx, DevAddress, I2C_DIRECTION_RECEIVE) != 0) {&#10;        i2c_generate_stop(I2Cx);&#10;        return 1; // Error sending address&#10;    }&#10;    &#10;    /* Receive data */&#10;    if (Size == 1) {&#10;        /* Disable Acknowledge */&#10;        I2Cx-&gt;CR1 &amp;= ~I2C_CR1_ACK;&#10;        &#10;        /* Generate STOP condition */&#10;        i2c_generate_stop(I2Cx);&#10;        &#10;        /* Wait until RXNE flag is set */&#10;        if (i2c_wait_flag(I2Cx, I2C_FLAG_RXNE, 1, Timeout) != 0) {&#10;            return 1; // Error: RXNE timeout&#10;        }&#10;        &#10;        /* Read data from DR */&#10;        *pData = (uint8_t)I2Cx-&gt;DR;&#10;    }&#10;    else if (Size == 2) {&#10;        /* Enable POS */&#10;        I2Cx-&gt;CR1 |= I2C_CR1_POS;&#10;        &#10;        /* Clear ADDR flag */&#10;        __IO uint32_t tmp = I2Cx-&gt;SR1;&#10;        tmp = I2Cx-&gt;SR2;&#10;        (void)tmp;&#10;        &#10;        /* Disable Acknowledge */&#10;        I2Cx-&gt;CR1 &amp;= ~I2C_CR1_ACK;&#10;        &#10;        /* Wait until BTF flag is set */&#10;        if (i2c_wait_flag(I2Cx, I2C_FLAG_BTF, 1, Timeout) != 0) {&#10;            return 1; // Error: BTF timeout&#10;        }&#10;        &#10;        /* Generate STOP condition */&#10;        i2c_generate_stop(I2Cx);&#10;        &#10;        /* Read data from DR */&#10;        *pData = (uint8_t)I2Cx-&gt;DR;&#10;        pData++;&#10;        *pData = (uint8_t)I2Cx-&gt;DR;&#10;    }&#10;    else {&#10;        /* Clear ADDR flag */&#10;        __IO uint32_t tmp = I2Cx-&gt;SR1;&#10;        tmp = I2Cx-&gt;SR2;&#10;        (void)tmp;&#10;        &#10;        while (Size &gt; 3) {&#10;            /* Wait until RXNE flag is set */&#10;            if (i2c_wait_flag(I2Cx, I2C_FLAG_RXNE, 1, Timeout) != 0) {&#10;                i2c_generate_stop(I2Cx);&#10;                return 1; // Error: RXNE timeout&#10;            }&#10;            &#10;            /* Read data from DR */&#10;            *pData = (uint8_t)I2Cx-&gt;DR;&#10;            pData++;&#10;            Size--;&#10;        }&#10;        &#10;        /* When remaining bytes = 3 */&#10;        /* Wait until BTF flag is set */&#10;        if (i2c_wait_flag(I2Cx, I2C_FLAG_BTF, 1, Timeout) != 0) {&#10;            i2c_generate_stop(I2Cx);&#10;            return 1; // Error: BTF timeout&#10;        }&#10;        &#10;        /* Disable Acknowledge */&#10;        I2Cx-&gt;CR1 &amp;= ~I2C_CR1_ACK;&#10;        &#10;        /* Read data N-2 */&#10;        *pData = (uint8_t)I2Cx-&gt;DR;&#10;        pData++;&#10;        &#10;        /* Wait until BTF flag is set */&#10;        if (i2c_wait_flag(I2Cx, I2C_FLAG_BTF, 1, Timeout) != 0) {&#10;            i2c_generate_stop(I2Cx);&#10;            return 1; // Error: BTF timeout&#10;        }&#10;        &#10;        /* Generate STOP condition */&#10;        i2c_generate_stop(I2Cx);&#10;        &#10;        /* Read data N-1 */&#10;        *pData = (uint8_t)I2Cx-&gt;DR;&#10;        pData++;&#10;        &#10;        /* Read data N */&#10;        *pData = (uint8_t)I2Cx-&gt;DR;&#10;    }&#10;    &#10;    /* Reset POS bit */&#10;    I2Cx-&gt;CR1 &amp;= ~I2C_CR1_POS;&#10;    &#10;    return 0; // Success&#10;}&#10;&#10;/**&#10; * @brief Write to a memory address of an I2C slave device&#10; * &#10; * @details Sends device address, memory address, and data to write to that address&#10; * &#10; * @param I2Cx I2C instance (I2C1, I2C2, or I2C3)&#10; * @param DevAddress Target device address&#10; * @param MemAddress Internal memory address&#10; * @param MemAddSize Size of memory address (I2C_MEMADD_SIZE_8BIT or I2C_MEMADD_SIZE_16BIT)&#10; * @param pData Pointer to data buffer&#10; * @param Size Amount of data to be sent&#10; * @param Timeout Timeout value&#10; * @return uint8_t 0 if successful, 1 if error&#10; */&#10;uint8_t i2c_mem_write(I2C_TypeDef *I2Cx, uint16_t DevAddress, uint16_t MemAddress, &#10;                      uint8_t MemAddSize, uint8_t *pData, uint16_t Size, uint32_t Timeout) {&#10;    /* Check parameters */&#10;    if (Size == 0 || pData == NULL) {&#10;        return 1; // Error: Invalid parameters&#10;    }&#10;    &#10;    /* Wait until bus is free */&#10;    if (i2c_wait_flag(I2Cx, I2C_FLAG_BUSY, 0, I2C_TIMEOUT_BUSY_FLAG) != 0) {&#10;        return 1; // Error: Bus is busy&#10;    }&#10;    &#10;    /* Generate START condition */&#10;    if (i2c_generate_start(I2Cx) != 0) {&#10;        return 1; // Error generating START&#10;    }&#10;    &#10;    /* Send slave address (for write) */&#10;    if (i2c_send_address(I2Cx, DevAddress, I2C_DIRECTION_TRANSMIT) != 0) {&#10;        i2c_generate_stop(I2Cx);&#10;        return 1; // Error sending address&#10;    }&#10;    &#10;    /* Send memory address */&#10;    if (MemAddSize == I2C_MEMADD_SIZE_8BIT) {&#10;        /* Send 8-bit memory address */&#10;        I2Cx-&gt;DR = (uint8_t)(MemAddress &amp; 0xFF);&#10;        &#10;        /* Wait until TXE flag is set */&#10;        if (i2c_wait_flag(I2Cx, I2C_FLAG_TXE, 1, Timeout) != 0) {&#10;            i2c_generate_stop(I2Cx);&#10;            return 1; // Error: TXE timeout&#10;        }&#10;    }&#10;    else { // I2C_MEMADD_SIZE_16BIT&#10;        /* Send MSB of 16-bit memory address */&#10;        I2Cx-&gt;DR = (uint8_t)((MemAddress &gt;&gt; 8) &amp; 0xFF);&#10;        &#10;        /* Wait until TXE flag is set */&#10;        if (i2c_wait_flag(I2Cx, I2C_FLAG_TXE, 1, Timeout) != 0) {&#10;            i2c_generate_stop(I2Cx);&#10;            return 1; // Error: TXE timeout&#10;        }&#10;        &#10;        /* Send LSB of 16-bit memory address */&#10;        I2Cx-&gt;DR = (uint8_t)(MemAddress &amp; 0xFF);&#10;        &#10;        /* Wait until TXE flag is set */&#10;        if (i2c_wait_flag(I2Cx, I2C_FLAG_TXE, 1, Timeout) != 0) {&#10;            i2c_generate_stop(I2Cx);&#10;            return 1; // Error: TXE timeout&#10;        }&#10;    }&#10;    &#10;    /* Send data */&#10;    while (Size &gt; 0) {&#10;        /* Wait until TXE flag is set */&#10;        if (i2c_wait_flag(I2Cx, I2C_FLAG_TXE, 1, Timeout) != 0) {&#10;            i2c_generate_stop(I2Cx);&#10;            return 1; // Error: TXE timeout&#10;        }&#10;        &#10;        /* Write data to DR */&#10;        I2Cx-&gt;DR = *pData;&#10;        pData++;&#10;        Size--;&#10;        &#10;        /* Wait until BTF flag is set for last byte */&#10;        if (Size == 0) {&#10;            if (i2c_wait_flag(I2Cx, I2C_FLAG_BTF, 1, Timeout) != 0) {&#10;                i2c_generate_stop(I2Cx);&#10;                return 1; // Error: BTF timeout&#10;            }&#10;        }&#10;    }&#10;    &#10;    /* Generate STOP condition */&#10;    i2c_generate_stop(I2Cx);&#10;    &#10;    return 0; // Success&#10;}&#10;&#10;/**&#10; * @brief Read from a memory address of an I2C slave device&#10; * &#10; * @details Sends device address and memory address, then reads data from that address&#10; * &#10; * @param I2Cx I2C instance (I2C1, I2C2, or I2C3)&#10; * @param DevAddress Target device address&#10; * @param MemAddress Internal memory address&#10; * @param MemAddSize Size of memory address (I2C_MEMADD_SIZE_8BIT or I2C_MEMADD_SIZE_16BIT)&#10; * @param pData Pointer to data buffer&#10; * @param Size Amount of data to be read&#10; * @param Timeout Timeout value&#10; * @return uint8_t 0 if successful, 1 if error&#10; */&#10;uint8_t i2c_mem_read(I2C_TypeDef *I2Cx, uint16_t DevAddress, uint16_t MemAddress, &#10;                     uint8_t MemAddSize, uint8_t *pData, uint16_t Size, uint32_t Timeout) {&#10;    /* Check parameters */&#10;    if (Size == 0 || pData == NULL) {&#10;        return 1; // Error: Invalid parameters&#10;    }&#10;    &#10;    /* Wait until bus is free */&#10;    if (i2c_wait_flag(I2Cx, I2C_FLAG_BUSY, 0, I2C_TIMEOUT_BUSY_FLAG) != 0) {&#10;        return 1; // Error: Bus is busy&#10;    }&#10;    &#10;    /* Generate START condition */&#10;    if (i2c_generate_start(I2Cx) != 0) {&#10;        return 1; // Error generating START&#10;    }&#10;    &#10;    /* Send slave address (for write) */&#10;    if (i2c_send_address(I2Cx, DevAddress, I2C_DIRECTION_TRANSMIT) != 0) {&#10;        i2c_generate_stop(I2Cx);&#10;        return 1; // Error sending address&#10;    }&#10;    &#10;    /* Send memory address */&#10;    if (MemAddSize == I2C_MEMADD_SIZE_8BIT) {&#10;        /* Send 8-bit memory address */&#10;        I2Cx-&gt;DR = (uint8_t)(MemAddress &amp; 0xFF);&#10;        &#10;        /* Wait until TXE flag is set */&#10;        if (i2c_wait_flag(I2Cx, I2C_FLAG_TXE, 1, Timeout) != 0) {&#10;            i2c_generate_stop(I2Cx);&#10;            return 1; // Error: TXE timeout&#10;        }&#10;    }&#10;    else { // I2C_MEMADD_SIZE_16BIT&#10;        /* Send MSB of 16-bit memory address */&#10;        I2Cx-&gt;DR = (uint8_t)((MemAddress &gt;&gt; 8) &amp; 0xFF);&#10;        &#10;        /* Wait until TXE flag is set */&#10;        if (i2c_wait_flag(I2Cx, I2C_FLAG_TXE, 1, Timeout) != 0) {&#10;            i2c_generate_stop(I2Cx);&#10;            return 1; // Error: TXE timeout&#10;        }&#10;        &#10;        /* Send LSB of 16-bit memory address */&#10;        I2Cx-&gt;DR = (uint8_t)(MemAddress &amp; 0xFF);&#10;        &#10;        /* Wait until TXE flag is set */&#10;        if (i2c_wait_flag(I2Cx, I2C_FLAG_TXE, 1, Timeout) != 0) {&#10;            i2c_generate_stop(I2Cx);&#10;            return 1; // Error: TXE timeout&#10;        }&#10;    }&#10;    &#10;    /* Generate repeated START condition */&#10;    if (i2c_generate_start(I2Cx) != 0) {&#10;        return 1; // Error generating START&#10;    }&#10;    &#10;    /* Send slave address (for read) */&#10;    if (i2c_send_address(I2Cx, DevAddress, I2C_DIRECTION_RECEIVE) != 0) {&#10;        i2c_generate_stop(I2Cx);&#10;        return 1; // Error sending address&#10;    }&#10;    &#10;    /* Read data - same logic as in master_receive */&#10;    if (Size == 1) {&#10;        /* Disable Acknowledge */&#10;        I2Cx-&gt;CR1 &amp;= ~I2C_CR1_ACK;&#10;        &#10;        /* Clear ADDR flag */&#10;        __IO uint32_t tmp = I2Cx-&gt;SR1;&#10;        tmp = I2Cx-&gt;SR2;&#10;        (void)tmp;&#10;        &#10;        /* Generate STOP condition */&#10;        i2c_generate_stop(I2Cx);&#10;        &#10;        /* Wait until RXNE flag is set */&#10;        if (i2c_wait_flag(I2Cx, I2C_FLAG_RXNE, 1, Timeout) != 0) {&#10;            return 1; // Error: RXNE timeout&#10;        }&#10;        &#10;        /* Read data from DR */&#10;        *pData = (uint8_t)I2Cx-&gt;DR;&#10;    }&#10;    else if (Size == 2) {&#10;        /* Enable POS */&#10;        I2Cx-&gt;CR1 |= I2C_CR1_POS;&#10;        &#10;        /* Clear ADDR flag */&#10;        __IO uint32_t tmp = I2Cx-&gt;SR1;&#10;        tmp = I2Cx-&gt;SR2;&#10;        (void)tmp;&#10;        &#10;        /* Disable Acknowledge */&#10;        I2Cx-&gt;CR1 &amp;= ~I2C_CR1_ACK;&#10;        &#10;        /* Wait until BTF flag is set */&#10;        if (i2c_wait_flag(I2Cx, I2C_FLAG_BTF, 1, Timeout) != 0) {&#10;            return 1; // Error: BTF timeout&#10;        }&#10;        &#10;        /* Generate STOP condition */&#10;        i2c_generate_stop(I2Cx);&#10;        &#10;        /* Read data from DR */&#10;        *pData = (uint8_t)I2Cx-&gt;DR;&#10;        pData++;&#10;        *pData = (uint8_t)I2Cx-&gt;DR;&#10;    }&#10;    else {&#10;        /* Enable Acknowledge */&#10;        I2Cx-&gt;CR1 |= I2C_CR1_ACK;&#10;        &#10;        /* Clear ADDR flag */&#10;        __IO uint32_t tmp = I2Cx-&gt;SR1;&#10;        tmp = I2Cx-&gt;SR2;&#10;        (void)tmp;&#10;        &#10;        while (Size &gt; 3) {&#10;            /* Wait until RXNE flag is set */&#10;            if (i2c_wait_flag(I2Cx, I2C_FLAG_RXNE, 1, Timeout) != 0) {&#10;                i2c_generate_stop(I2Cx);&#10;                return 1; // Error: RXNE timeout&#10;            }&#10;            &#10;            /* Read data from DR */&#10;            *pData = (uint8_t)I2Cx-&gt;DR;&#10;            pData++;&#10;            Size--;&#10;        }&#10;        &#10;        /* When remaining bytes = 3 */&#10;        /* Wait until BTF flag is set */&#10;        if (i2c_wait_flag(I2Cx, I2C_FLAG_BTF, 1, Timeout) != 0) {&#10;            i2c_generate_stop(I2Cx);&#10;            return 1; // Error: BTF timeout&#10;        }&#10;        &#10;        /* Disable Acknowledge */&#10;        I2Cx-&gt;CR1 &amp;= ~I2C_CR1_ACK;&#10;        &#10;        /* Read data N-2 */&#10;        *pData = (uint8_t)I2Cx-&gt;DR;&#10;        pData++;&#10;        &#10;        /* Wait until BTF flag is set */&#10;        if (i2c_wait_flag(I2Cx, I2C_FLAG_BTF, 1, Timeout) != 0) {&#10;            i2c_generate_stop(I2Cx);&#10;            return 1; // Error: BTF timeout&#10;        }&#10;        &#10;        /* Generate STOP condition */&#10;        i2c_generate_stop(I2Cx);&#10;        &#10;        /* Read data N-1 */&#10;        *pData = (uint8_t)I2Cx-&gt;DR;&#10;        pData++;&#10;        &#10;        /* Read data N */&#10;        *pData = (uint8_t)I2Cx-&gt;DR;&#10;    }&#10;    &#10;    /* Reset POS bit */&#10;    I2Cx-&gt;CR1 &amp;= ~I2C_CR1_POS;&#10;    &#10;    /* Enable Acknowledge */&#10;    I2Cx-&gt;CR1 |= I2C_CR1_ACK;&#10;    &#10;    return 0; // Success&#10;}&#10;&#10;/**&#10; * @brief Check if a device is ready to communicate&#10; * &#10; * @details Sends device address and checks for ACK, useful for polling device status&#10; * &#10; * @param I2Cx I2C instance (I2C1, I2C2, or I2C3)&#10; * @param DevAddress Target device address&#10; * @param Trials Number of trials&#10; * @param Timeout Timeout value&#10; * @return uint8_t 0 if device is ready, 1 if not ready&#10; */&#10;uint8_t i2c_is_device_ready(I2C_TypeDef *I2Cx, uint16_t DevAddress, uint8_t Trials, uint32_t Timeout) {&#10;    uint32_t tickstart = 0;&#10;    &#10;    /* Get current tick */&#10;    tickstart = 0; // Replace with actual tick counter&#10;    &#10;    while (Trials &gt; 0) {&#10;        /* Check if the bus is free */&#10;        if (i2c_wait_flag(I2Cx, I2C_FLAG_BUSY, 0, I2C_TIMEOUT_BUSY_FLAG) != 0) {&#10;            return 1; // Error: Bus is busy&#10;        }&#10;        &#10;        /* Generate START condition */&#10;        I2Cx-&gt;CR1 |= I2C_CR1_START;&#10;        &#10;        /* Wait until SB flag is set */&#10;        if (i2c_wait_flag(I2Cx, I2C_FLAG_SB, 1, Timeout) != 0) {&#10;            i2c_generate_stop(I2Cx);&#10;            return 1; // Error generating START&#10;        }&#10;        &#10;        /* Send slave address */&#10;        I2Cx-&gt;DR = (uint8_t)((DevAddress &lt;&lt; 1) | I2C_DIRECTION_TRANSMIT);&#10;        &#10;        /* Wait until ADDR or AF flag is set */&#10;        while ((I2Cx-&gt;SR1 &amp; (I2C_FLAG_ADDR | 0x400)) == 0) {&#10;            /* Check for timeout */&#10;            if ((0 - tickstart) &gt; Timeout) { // Replace with actual tick calculation&#10;                i2c_generate_stop(I2Cx);&#10;                return 1; // Timeout&#10;            }&#10;        }&#10;        &#10;        /* Check if ADDR flag is set (ACK received) */&#10;        if ((I2Cx-&gt;SR1 &amp; I2C_FLAG_ADDR) != 0) {&#10;            /* Clear ADDR flag */&#10;            __IO uint32_t tmp = I2Cx-&gt;SR1;&#10;            tmp = I2Cx-&gt;SR2;&#10;            (void)tmp;&#10;            &#10;            /* Generate STOP condition */&#10;            i2c_generate_stop(I2Cx);&#10;            &#10;            return 0; // Device is ready&#10;        }&#10;        else {&#10;            /* Clear AF flag */&#10;            I2Cx-&gt;SR1 &amp;= ~0x400;&#10;        }&#10;        &#10;        /* Generate STOP condition */&#10;        i2c_generate_stop(I2Cx);&#10;        &#10;        /* Decrement trials */&#10;        Trials--;&#10;        &#10;        /* Wait for a while */&#10;        for (uint32_t i = 0; i &lt; 10000; i++) {&#10;            __NOP();&#10;        }&#10;    }&#10;    &#10;    return 1; // Device is not ready&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>